[
  {
    "model": "admin.logentry",
    "pk": 1,
    "fields": {
      "action_time": "2024-09-06T10:31:08.993Z",
      "user": 1,
      "content_type": 7,
      "object_id": "1",
      "object_repr": "наименование модуля: Подключение к серверу и его настройка, описание модуля: Деплой и настройка проекта с использованием CI/CD-процессов — важная часть разработки программного обеспечения. Для разверт",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 2,
    "fields": {
      "action_time": "2024-09-10T11:41:01.332Z",
      "user": 1,
      "content_type": 6,
      "object_id": "1",
      "object_repr": "наименование курса: Деплой и CI/CD",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Studying users\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 3,
    "fields": {
      "action_time": "2024-09-12T13:10:32.060Z",
      "user": 1,
      "content_type": 10,
      "object_id": "9",
      "object_repr": "наименование шага: Ключ доступа SSH",
      "action_flag": 2,
      "change_message": "[]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 4,
    "fields": {
      "action_time": "2024-09-12T13:10:46.474Z",
      "user": 1,
      "content_type": 10,
      "object_id": "9",
      "object_repr": "наименование шага: Ключ доступа SSH",
      "action_flag": 2,
      "change_message": "[]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 5,
    "fields": {
      "action_time": "2024-09-15T18:20:47.232Z",
      "user": 1,
      "content_type": 12,
      "object_id": "5",
      "object_repr": "django0292@gmail.com: (наименование курса: тест1 название курса, 1 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 6,
    "fields": {
      "action_time": "2024-09-15T18:20:52.143Z",
      "user": 1,
      "content_type": 12,
      "object_id": "6",
      "object_repr": "django0292@gmail.com: (None, 0 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 7,
    "fields": {
      "action_time": "2024-09-15T18:45:57.938Z",
      "user": 1,
      "content_type": 6,
      "object_id": "3",
      "object_repr": "наименование курса: тест1 название курса",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Studying users\", \"\\u0426\\u0435\\u043d\\u0430 \\u0432 \\u0440\\u0443\\u0431\\u043b\\u044f\\u0445\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 8,
    "fields": {
      "action_time": "2024-09-15T19:00:25.067Z",
      "user": 1,
      "content_type": 12,
      "object_id": "13",
      "object_repr": "django0292@gmail.com: (наименование курса: название тестового курса 4, 3000.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 9,
    "fields": {
      "action_time": "2024-09-15T19:00:25.072Z",
      "user": 1,
      "content_type": 12,
      "object_id": "12",
      "object_repr": "django0292@gmail.com: (наименование курса: название тестового курса 4, 3000.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 10,
    "fields": {
      "action_time": "2024-09-15T19:00:25.077Z",
      "user": 1,
      "content_type": 12,
      "object_id": "11",
      "object_repr": "django0292@gmail.com: (наименование курса: тест1 название курса, 1.03 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 11,
    "fields": {
      "action_time": "2024-09-15T19:00:25.080Z",
      "user": 1,
      "content_type": 12,
      "object_id": "10",
      "object_repr": "django0292@gmail.com: (наименование курса: тест1 название курса, 1.03 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 12,
    "fields": {
      "action_time": "2024-09-15T19:00:25.082Z",
      "user": 1,
      "content_type": 12,
      "object_id": "9",
      "object_repr": "django0292@gmail.com: (наименование курса: тест1 название курса, 1.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 13,
    "fields": {
      "action_time": "2024-09-15T19:00:25.084Z",
      "user": 1,
      "content_type": 12,
      "object_id": "8",
      "object_repr": "django0292@gmail.com: (наименование курса: тест1 название курса, 1.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 14,
    "fields": {
      "action_time": "2024-09-16T08:33:50.721Z",
      "user": 1,
      "content_type": 12,
      "object_id": "15",
      "object_repr": "django0292@gmail.com: (наименование курса: название тестового курса 4, 3000.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 15,
    "fields": {
      "action_time": "2024-09-16T08:33:58.195Z",
      "user": 1,
      "content_type": 12,
      "object_id": "14",
      "object_repr": "django0292@gmail.com: (наименование курса: название тестового курса 4, 3000.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "admin.logentry",
    "pk": 16,
    "fields": {
      "action_time": "2024-09-16T08:34:09.747Z",
      "user": 1,
      "content_type": 12,
      "object_id": "16",
      "object_repr": "django0292@gmail.com: (наименование курса: название тестового курса 4, 3000.00 руб.)",
      "action_flag": 3,
      "change_message": ""
    }
  },
  {
    "model": "sessions.session",
    "pk": "ksvzyejcy45m54hvbcuj8253ti60nyku",
    "fields": {
      "session_data": ".eJxVjDsOwyAQRO9CHSEWg4GU6X0GtMsnOIlAMnYV5e6xJRdJN5r3Zt7M47YWv_W0-DmyKwN2-e0IwzPVA8QH1nvjodV1mYkfCj9p51OL6XU73b-Dgr3sa2mjFSGiHJREcKBIGO1kIAkk7JAEKLXH7HQeEmQwAWIYURihR1LJss8XwrA3Hw:1sqdlB:fZlUBG-IAIY2DUnRrB3BjUClxmV9zKKCRVPJhqYi_gU",
      "expire_date": "2024-10-01T19:21:13.530Z"
    }
  },
  {
    "model": "content_app.course",
    "pk": 1,
    "fields": {
      "name": "Деплой и CI/CD",
      "description": "Практические навыки работы с GitLab, а также принципы и порядок развертывания приложения на серверах специфичен для каждой компании, и вы сможете отработать их на реальных проектах.",
      "image": "course/images/2_GnOfg2M.jpeg",
      "is_published": true,
      "owner": 1,
      "cost": "0.00",
      "studying_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.course",
    "pk": 2,
    "fields": {
      "name": "Разработка на FastAPI",
      "description": "Вы изучите основные аспекты асинхронного программирования в Python, а также научитесь использовать библиотеку \r\nasyncio\r\n для написания асинхронного кода.",
      "image": "course/images/5.jpeg",
      "is_published": true,
      "owner": 1,
      "cost": "0.00",
      "studying_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.course",
    "pk": 3,
    "fields": {
      "name": "70 вопросов к собеседованию",
      "description": "70 вопросов к собеседованию Python Django",
      "image": "course/images/72.jpg",
      "is_published": true,
      "owner": 1,
      "cost": "0.00",
      "studying_users": [
        2,
        1
      ]
    }
  },
  {
    "model": "content_app.course",
    "pk": 6,
    "fields": {
      "name": "название тестового курса 5",
      "description": "описание тестового курса 5",
      "image": "",
      "is_published": false,
      "owner": 2,
      "cost": "0.00",
      "studying_users": []
    }
  },
  {
    "model": "content_app.module",
    "pk": 2,
    "fields": {
      "ordering_number": 2,
      "name": "Запуск проекта на удаленном сервере",
      "course": 1
    }
  },
  {
    "model": "content_app.module",
    "pk": 3,
    "fields": {
      "ordering_number": 1,
      "name": "Подключение к серверу и его настройка",
      "course": 1
    }
  },
  {
    "model": "content_app.module",
    "pk": 5,
    "fields": {
      "ordering_number": 3,
      "name": "название модуля 3",
      "course": 1
    }
  },
  {
    "model": "content_app.module",
    "pk": 6,
    "fields": {
      "ordering_number": 4,
      "name": "название модуля 4",
      "course": 1
    }
  },
  {
    "model": "content_app.module",
    "pk": 7,
    "fields": {
      "ordering_number": 5,
      "name": "название модуля 5",
      "course": 1
    }
  },
  {
    "model": "content_app.module",
    "pk": 8,
    "fields": {
      "ordering_number": 1,
      "name": "модуль 1 курса 2",
      "course": 2
    }
  },
  {
    "model": "content_app.module",
    "pk": 9,
    "fields": {
      "ordering_number": 2,
      "name": "модуль 2 курса 2",
      "course": 2
    }
  },
  {
    "model": "content_app.module",
    "pk": 10,
    "fields": {
      "ordering_number": 3,
      "name": "модуль 3 курса 2",
      "course": 2
    }
  },
  {
    "model": "content_app.module",
    "pk": 11,
    "fields": {
      "ordering_number": 1,
      "name": "название модуля 1 курса 6(5)",
      "course": 6
    }
  },
  {
    "model": "content_app.module",
    "pk": 12,
    "fields": {
      "ordering_number": 2,
      "name": "название модуля 2 курса 6(5)",
      "course": 6
    }
  },
  {
    "model": "content_app.module",
    "pk": 13,
    "fields": {
      "ordering_number": 1,
      "name": "вопросы 1-20",
      "course": 3
    }
  },
  {
    "model": "content_app.module",
    "pk": 14,
    "fields": {
      "ordering_number": 2,
      "name": "вопросы 21-40",
      "course": 3
    }
  },
  {
    "model": "content_app.module",
    "pk": 15,
    "fields": {
      "ordering_number": 3,
      "name": "вопросы 41-60",
      "course": 3
    }
  },
  {
    "model": "content_app.module",
    "pk": 20,
    "fields": {
      "ordering_number": 4,
      "name": "вопросы 61-70",
      "course": 3
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 2,
    "fields": {
      "name": "Схема работы проекта",
      "module": 2,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 4,
    "fields": {
      "name": "SSH и ключи SSH.",
      "module": 3,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 5,
    "fields": {
      "name": "ПО для развертывания Django-проекта.",
      "module": 3,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 6,
    "fields": {
      "name": "урок1 модуля1 курса2",
      "module": 8,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 7,
    "fields": {
      "name": "назв_урока1_модуля1_курса6(5)",
      "module": 11,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 8,
    "fields": {
      "name": "назв_урока2_модуля1_курса6(5)",
      "module": 11,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 9,
    "fields": {
      "name": "вопросы 1-10",
      "module": 13,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 10,
    "fields": {
      "name": "вопросы 11-20",
      "module": 13,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 14,
    "fields": {
      "name": "вопросы 21-30",
      "module": 14,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 15,
    "fields": {
      "name": "вопросы 31-40",
      "module": 14,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 18,
    "fields": {
      "name": "вопросы 41-50",
      "module": 15,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 19,
    "fields": {
      "name": "вопросы 51-60",
      "module": 15,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 20,
    "fields": {
      "name": "вопросы 61-65",
      "module": 20,
      "ordering_number": 1
    }
  },
  {
    "model": "content_app.lesson",
    "pk": 21,
    "fields": {
      "name": "вопросы 66-70",
      "module": 20,
      "ordering_number": 2
    }
  },
  {
    "model": "content_app.step",
    "pk": 1,
    "fields": {
      "name": "Схема работы проекта относительно пользователя",
      "content": "<p>Опрделения:</p>\r\n<ul>\r\n<li>Веб-сервер &mdash; удаленный сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиапотоком или другими данными.</li>\r\n<li><span class=\"-type-strong root\">Nginx</span> &mdash; веб-сервер, работающий на Unix-подобных операционных системах.</li>\r\n<li><span class=\"-type-strong root\">Gunicorn</span> &mdash; это HTTP-сервер с интерфейсом шлюза веб-сервера Python. Это предварительная рабочая модель, портированная из проекта Ruby Unicorn.</li>\r\n</ul>\r\n<p>&nbsp;</p>\r\n<p><img src=\"https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/1368x/https://cdn-user12724.skyeng.ru/image/ab253d943e31cbed796f9c790be08235.png\" width=\"998\" height=\"492\"></p>\r\n<p>Пользователь обращается к удаленному веб-серверу по адресу, который он указывает в адресной строке браузера (или другого клиента, например Postman).</p>\r\n<p>Сервер принимает входящий запрос, однако Django не умеет работать как веб-сервер вне локальной версии. То есть чтобы принимать запросы на сервере по доменному имени или IP-адресу, нужен веб-сервер. Один из вариантов &mdash; это Nginx.</p>\r\n<p>Однако Nginx и Django не умеют взаимодействовать напрямую, поэтому в качестве шлюза передачи данных между ними встраивается Gunicorn.</p>\r\n<p>В свою очередь, Gunicorn работает как демон, что позволяет настроить супервизоры для контроля работоспособности проекта.</p>",
      "lesson": 2,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 7,
    "fields": {
      "name": "ПО для развертывания Django-проекта",
      "content": "ПО для развертывания Django-проекта.\r\nДля успешного развертывания Django-проекта вам понадобятся следующие компоненты:\r\n\r\n Веб-сервер Gunicorn (Green Unicorn) — это WSGI-совместимый веб-сервер, который будет обрабатывать запросы к вашему Django-приложению.\r\n СУБД PostgreSQL — для хранения данных вашего Django-проекта.\r\n Система инициализации systemd — для управления процессом Gunicorn как сервисом.",
      "lesson": 5,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 8,
    "fields": {
      "name": "SSH",
      "content": "<blockquote class=\"-importance-medium root\">\r\n<p><span class=\"-type-strong root\">SSH (Secure Shell)</span>&nbsp;&mdash; сетевой протокол прикладного уровня, позволяющий удаленно управлять операционной системой.</p>\r\n</blockquote>\r\n<p>&nbsp;</p>\r\n<div class=\"-align- -float- root ng-star-inserted\">\r\n<div class=\"image-holder\"><img src=\"https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/1368x/https://cdn-user12724.skyeng.ru/image/bd6d00fdbbb2a4ab0182f6456a4423fe.png\" alt=\"\" width=\"100%\"></div>\r\n</div>\r\n<p>SSH используется для безопасного подключения к серверу и выполнения команд на удаленной машине. Для начала убедитесь, что SSH установлен на вашем локальном компьютере и на сервере.</p>",
      "lesson": 4,
      "ordering_number": 1,
      "steps_used_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 9,
    "fields": {
      "name": "Ключ доступа SSH",
      "content": "<p><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/1368x/https://cdn-user12724.skyeng.ru/image/ddf808326139d013b519915353c7a99d.png\" width=\"1006\" height=\"372\"></p>\r\n<p>&nbsp;</p>\r\n<p>1. Для начала убедитесь, что SSH установлен на вашем локальном компьютере и на сервере.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>2. Затем с помощью команды создайте SSH-ключ на локальной машине, если у вас его еще нет:</p>\r\n<pre class=\"-mode-inline root\"><code class=\"hljs\">ssh-keygen -t rsa -b <span class=\"hljs-number\">4096</span> -C <span class=\"hljs-string\">\"your_email@example.com\"</span></code></pre>\r\n<p>&nbsp;</p>\r\n<blockquote class=\"-importance-medium root\">\r\n<p><span class=\"-type-strong root\">Ключ доступа SSH</span>&nbsp;&mdash; это криптографический ключ, используемый для аутентификации при подключении к серверу по SSH вместо пароля. Он состоит из публичной и приватной частей, где публичная сохраняется на сервере, а приватная&nbsp;&mdash; на локальном компьютере.</p>\r\n</blockquote>\r\n<p>&nbsp;</p>\r\n<p>3. Результат работы команды по умолчанию складывается в файлы <code class=\"hljs\">/home/username/.ssh/id_rsa</code> и&nbsp;<code class=\"hljs\">/home/username/.ssh/id_rsa.pub</code></p>\r\n<div class=\"-align- -float- root ng-star-inserted\">\r\n<div class=\"image-holder\">&nbsp;</div>\r\n</div>\r\n<p>4. После того как SSH-ключ создан, скопируйте публичный ключ на сервер с помощью команды <code class=\"hljs\">ssh-copy-<span class=\"hljs-built_in\">id</span></code>:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"-mode-inline root\"><code class=\"hljs\">ssh-copy-<span class=\"hljs-built_in\">id</span> username@server_ip</code></pre>\r\n<p>&nbsp;</p>\r\n<p>5. Теперь можете подключаться к удаленному серверу с помощью команды без ввода пароля:</p>\r\n<pre class=\"-mode-inline root\"><code class=\"hljs\">ssh username@server_ip</code></pre>\r\n<p>&nbsp;</p>\r\n<blockquote class=\"-importance-medium root\">\r\n<p>&nbsp;</p>\r\n<pre class=\"-mode-inline root\"><code class=\"hljs\"><span class=\"hljs-comment\"># Для Windows</span>\r\nscp C:/Users/.ssh/id_rca.pub username@server_ip:.ssh/authorized_key\r\n\r\nscp - команда для копирования между удаленными компьюетрами\r\nC:/Users/.ssh/id_rca.pub - путь до публичного токена без кириллицы\r\nusername@server_ip:.ssh/authorized_key - путь до файла где храниться токен на сервере</code></pre>\r\n<p>&nbsp;</p>\r\n</blockquote>",
      "lesson": 4,
      "ordering_number": 2,
      "steps_used_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 11,
    "fields": {
      "name": "Деплой (Deploy) Необходимые настройки для запуска проекта",
      "content": "<div>Деплой (Deploy)&nbsp; &mdash; развертывание программного обеспечения. Это все действия, которые делают программную систему готовой к использованию. Данный процесс является частью жизненного цикла программного обеспечения. В целом процесс развертывания состоит из нескольких взаимосвязанных действий с возможными переходами между ними.</div>\r\n<div>&nbsp;</div>\r\n<div>Основные шаги деплоя:</div>\r\n<div>&nbsp;</div>\r\n<ol>\r\n<li>Подключение к серверу.</li>\r\n<li>Копирование исходников.</li>\r\n<li>Настройка демона.</li>\r\n<li>Настройка веб-сервера.</li>\r\n</ol>\r\n<div>&nbsp;</div>\r\n<div>Ниже рассмотренны настройки для запуска проекта:</div>\r\n<div>&nbsp;</div>\r\n<ol>\r\n<li>Настройка сервера:</li>\r\n<li>Настройка Gunicorn и systemd:</li>\r\n<li>&nbsp;Настройка Nginx:</li>\r\n</ol>\r\n<div>&nbsp;</div>\r\n<div>Необходимые настройки для запуска проекта</div>\r\n<div>\r\n<ol>\r\n<li style=\"font-weight: bold;\"><strong>&nbsp;Настройка сервера:</strong></li>\r\n</ol>\r\n</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Установите необходимое ПО на сервере. В большинстве дистрибутивов Linux это можно сделать с помощью менеджера пакетов. Например, для Ubuntu:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">sudo apt-get update</div>\r\n<div style=\"padding-left: 120px;\">sudo apt-get install postgresql postgresql-contrib python3-pip</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Создайте базу данных и пользователя PostgreSQL для вашего проекта:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">sudo -u postgres psql</div>\r\n<div style=\"padding-left: 120px;\">CREATE DATABASE yourdbname;</div>\r\n<div style=\"padding-left: 120px;\">CREATE USER yourdbuser WITH PASSWORD 'yourpassword';</div>\r\n<div style=\"padding-left: 120px;\">ALTER ROLE yourdbuser SET client_encoding TO 'utf8';</div>\r\n<div style=\"padding-left: 120px;\">ALTER ROLE yourdbuser SET default_transaction_isolation TO 'read committed';</div>\r\n<div style=\"padding-left: 120px;\">ALTER ROLE yourdbuser SET timezone TO 'UTC';</div>\r\n<div style=\"padding-left: 120px;\">GRANT ALL PRIVILEGES ON DATABASE yourdbname TO yourdbuser;</div>\r\n<div style=\"padding-left: 120px;\">\\\\q</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Установите необходимые Python-пакеты на сервер с помощью&nbsp;</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">pip:</div>\r\n<div style=\"padding-left: 120px;\">pip3 install virtualenv</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Скопируйте свой Django-проект на сервер (например, через&nbsp;git clone или через SCP).</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div>\r\n<p><strong>&nbsp; &nbsp; 2. Настройка Gunicorn и systemd:</strong></p>\r\n</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Создайте виртуальное окружение для вашего проекта:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">virtualenv venv</div>\r\n<div style=\"padding-left: 120px;\">source venv/bin/activate</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Установите зависимости проекта:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">pip install -r requirements.txt</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Создайте файл конфигурации Gunicorn (например, gunicorn_config.py) и настройте его.</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Создайте unit-файл для systemd (например, yourproject.service ) для управления Gunicorn как сервисом.</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n<p style=\"padding-left: 80px;\">Пример unit-файла:</p>\r\n</div>\r\n<div style=\"padding-left: 120px;\">[Unit]</div>\r\n<div style=\"padding-left: 120px;\">Description=gunicorn daemon for Your Project # Описание вашего сервиса</div>\r\n<div style=\"padding-left: 120px;\">After=network.target # Сервис, от которого будет зависеть запуск проекта</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">[Service]</div>\r\n<div style=\"padding-left: 120px;\">User=yourusername # Имя пользователя владельца проекта в Linux</div>\r\n<div style=\"padding-left: 120px;\">Group=yourgroupname # Группа, к которой относится пользователь</div>\r\n<div style=\"padding-left: 120px;\">WorkingDirectory=/path/to/your/project # Путь к рабочей директории проекта</div>\r\n<div style=\"padding-left: 120px;\">ExecStart=/path/to/venv/bin/gunicorn --config /path/to/gunicorn_config.py your_project.wsgi:application</div>\r\n<div style=\"padding-left: 120px;\"># Команда для запуска проекта</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">[Install]</div>\r\n<div style=\"padding-left: 120px;\">WantedBy=multi-user.target # Ожидание запуска системы в нормальном состоянии доступа для пользователей</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Запустите и активируйте сервис:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">sudo systemctl start yourproject</div>\r\n<div style=\"padding-left: 120px;\">sudo systemctl enable yourproject</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<p><strong>3. Настройка Nginx:</strong></p>\r\n</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Создайте конфигурацию Nginx для вашего проекта:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\"># /etc/nginx/sites-available/my_site</div>\r\n<div style=\"padding-left: 120px;\">server {</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; listen 80;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; server_name &lt;ip адрес или доменное имя сервера&gt;;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; location /static/ {</div>\r\n<div style=\"padding-left: 280px;\">root /path/to/your/project/;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; }</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; location /media/ {</div>\r\n<div style=\"padding-left: 280px;\">root /path/to/your/project/;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; }</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; location / {</div>\r\n<div style=\"padding-left: 240px;\">include proxy_params;</div>\r\n<div style=\"padding-left: 240px;\">proxy_pass /path/to/your/project/project.sock</div>\r\n<div style=\"padding-left: 120px;\">&nbsp; &nbsp; }</div>\r\n<div style=\"padding-left: 120px;\">&nbsp;</div>\r\n<div style=\"padding-left: 120px;\">}</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Проверьте корректность настроек Nginx:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">nginx -t</div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>Подключите сайт к отображению:</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<div style=\"padding-left: 120px;\">ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled</div>\r\n<div>&nbsp;</div>\r\n<div>Все эти шаги являются деплоем, или доставкой кода проекта на удаленный сервер.</div>",
      "lesson": 2,
      "ordering_number": 2,
      "steps_used_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 12,
    "fields": {
      "name": "название шага 3",
      "content": "контент шага 3",
      "lesson": 2,
      "ordering_number": 3,
      "steps_used_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 13,
    "fields": {
      "name": "название шага 4",
      "content": "контент шага 4",
      "lesson": 2,
      "ordering_number": 4,
      "steps_used_users": [
        1,
        2
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 14,
    "fields": {
      "name": "шаг1",
      "content": null,
      "lesson": 6,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 15,
    "fields": {
      "name": "шаг2",
      "content": null,
      "lesson": 6,
      "ordering_number": 2,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 16,
    "fields": {
      "name": "шаг3",
      "content": null,
      "lesson": 6,
      "ordering_number": 3,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 17,
    "fields": {
      "name": "шаг1_урока1_модуля1_курса6(5)",
      "content": null,
      "lesson": 7,
      "ordering_number": 1,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 18,
    "fields": {
      "name": "шаг2_урока1_модуля1_курса6(5)",
      "content": null,
      "lesson": 7,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 19,
    "fields": {
      "name": "1. Перечисли операторы, которые тебе известны.",
      "content": "<ol>\r\n<li>Арифметические операторы +, - , *, /, **, //, %</li>\r\n<li>Операторы сравнения &lt; ,&gt; ,&lt;=, &gt;=, ==, !=</li>\r\n<li>Операторы присваивания =, +=, -=, /=, *=, %=, **=, //=</li>\r\n<li>Логические операторы and, or, not</li>\r\n<li>Операторы принадлежности in, not in,&nbsp;</li>\r\n<li>Операторы тождественности is, is not,</li>\r\n<li>Битовые операторы&nbsp;&nbsp;&amp;(бинарное и), |(бинарное или), ^(бинарное или не), ~(инвертирующий) , &gt;&gt;, &lt;&lt;,</li>\r\n</ol>",
      "lesson": 9,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 20,
    "fields": {
      "name": "1.1 Арифметические операторы в Python",
      "content": "<ul>\r\n<li>+,</li>\r\n<li>&nbsp;- ,</li>\r\n<li>&nbsp;*,</li>\r\n<li>/,</li>\r\n<li>**,</li>\r\n<li>&nbsp;//,</li>\r\n<li>&nbsp;%</li>\r\n</ul>",
      "lesson": 9,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 21,
    "fields": {
      "name": "1.2 Операторы сравнения",
      "content": "<ol>\r\n<li>&nbsp;&lt; ,</li>\r\n<li>&gt; ,</li>\r\n<li>&lt;=,</li>\r\n<li>&nbsp;&gt;=,</li>\r\n<li>&nbsp;==,</li>\r\n<li>&nbsp;!=</li>\r\n</ol>",
      "lesson": 9,
      "ordering_number": 2,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 22,
    "fields": {
      "name": "1.3 Операторы присваивания",
      "content": "<p style=\"padding-left: 80px;\">=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;+=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;-=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;/=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;*=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;%=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;**=,</p>\r\n<p style=\"padding-left: 80px;\">&nbsp;//=</p>",
      "lesson": 9,
      "ordering_number": 3,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 23,
    "fields": {
      "name": "1.4 Логические операторы",
      "content": "<p style=\"text-align: center;\">Логические операторы</p>\r\n<p style=\"text-align: center;\"><strong>and, or, not</strong></p>",
      "lesson": 9,
      "ordering_number": 4,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 24,
    "fields": {
      "name": "1.5 Операторы принадлежности",
      "content": "<p style=\"text-align: center;\">Операторы принадлежности</p>\r\n<p style=\"text-align: center;\"><strong>in, not in,&nbsp;</strong></p>",
      "lesson": 9,
      "ordering_number": 5,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 25,
    "fields": {
      "name": "1.6 Операторы тождественности",
      "content": "<p style=\"text-align: center;\">Операторы тождественности</p>\r\n<p style=\"text-align: center;\"><strong>&nbsp;is, is not</strong></p>",
      "lesson": 9,
      "ordering_number": 6,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 26,
    "fields": {
      "name": "1.7 Битовые операторы",
      "content": "<p style=\"padding-left: 80px; text-align: center;\">Битовые операторы&nbsp;&nbsp;</p>\r\n<ul>\r\n<li>&amp;(бинарное и),</li>\r\n<li>&nbsp;|(бинарное или),</li>\r\n<li>&nbsp;^(бинарное или не),</li>\r\n<li>&nbsp;~(инвертирующий) ,</li>\r\n<li>&nbsp;&gt;&gt;,</li>\r\n<li>&nbsp;&lt;&lt;,</li>\r\n</ul>",
      "lesson": 9,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 27,
    "fields": {
      "name": "2. Что такое объекты функций и как с ними работать?",
      "content": null,
      "lesson": 9,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 28,
    "fields": {
      "name": "3. Дай определение конструкции \"f-строка\"",
      "content": "<p><strong>F-строки в Python</strong>&nbsp;&mdash; это строковые литералы, в которых перед открывающейся кавычкой стоит символ f.<br><br>&nbsp;Они могут включать в себя выражения Python, заключённые в фигурные скобки.<br>&nbsp;Python заменит эти выражения на итоговые значения.&nbsp;<br><br><strong>Чтобы создать f-строку</strong>, нужно всего лишь добавить букву f&nbsp;или F&nbsp;перед открывающими кавычками строки.<br><br>&nbsp;Например,&nbsp;</p>\r\n<pre>\"This\"&nbsp;&mdash; это строка, тогда как&nbsp;</pre>\r\n<pre>f\"This\" &mdash; это f-строка.&nbsp;</pre>",
      "lesson": 9,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 29,
    "fields": {
      "name": "4. Как расшифровывается CRUD?",
      "content": "<div><strong>CRUD</strong>&nbsp;&mdash; это сокращение от&nbsp;<strong>Create (создание), Read (чтение), Update (модификация) и Delete (удаление)</strong>.</div>\r\n<div>Эти четыре функции являются ключевыми принципами, которым следуют разработчики и программисты API при создании надёжных API.</div>\r\n<div>К языкам программирования, использующим инфраструктуру CRUD, относятся:&nbsp;<strong>Python, PHP, Java и .Net</strong>.</div>",
      "lesson": 9,
      "ordering_number": 11,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 30,
    "fields": {
      "name": "5. Расскажи про ORM: что это и где применяется?",
      "content": "<div><strong>Объектно-реляционный преобразователь (ORM)</strong>&nbsp;&mdash; это библиотека кода, которая автоматизирует перенос данных, хранящихся в таблицах реляционной базы данных, в объекты, которые используются в коде приложения.</div>\r\n<div><strong>ORM предоставляют высокоуровневую абстракцию реляционной базы данных</strong>, которая позволяет разработчику писать код Python вместо SQL для создания, чтения, обновления и удаления данных и схем в своей базе данных.</div>\r\n<div><strong>ORM могут использоваться для:</strong></div>\r\n<div>&mdash; ускорения разработки веб-приложений, особенно в начале проекта;<br>&mdash; переключения приложения между различными реляционными базами данных.</div>\r\n<div>Доступ к базе через Python ORM может осуществляться как в рамках соответствующих фреймворков Django, Flask, Tornado, так и на низком уровне с помощью библиотек коннекторов.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>В нашем коде мы работаем с объектами разной природы, а при работе с SQL базой данных мы вынуждены постоянно генерировать текстовые запросы к базе, а получив ответ от базы обратно его преобразовывать в формат данных нашего приложения.<br><br>Хорошо было бы иметь некий механизм автоматического генерирования этих запросов исходя из заранее определенной структуры наших данных и приведения ответа к этой же структуре. Именно таким механизмом является добавление дополнительной ORM-прослойки между кодом нашего приложения и SQL базой.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div><strong>ORM (объектно-реляционное представление)</strong>&nbsp;&mdash; это прослойка, которая позволяет работать с базой данных, используя классы и методы вместо написания сложных SQL-запросов.</div>\r\n<div><strong>Основные возможности и преимущества использования ORM в Django:</strong></div>\r\n<div>&mdash; Моделирование базы данных.<br>&mdash; Простой доступ к данным.<br>&mdash; Гибкое обновление структуры базы данных.<br>&mdash; Автоматическая валидация данных.<br>&mdash; Защита от SQL-инъекций.<br>&mdash; Переносимость &mdash; можно легко переключаться между разными базами данных, не меняя код приложения.<br>&mdash; Кеширование запросов для повышения производительности.<br>&mdash; Разнообразная дополнительная функциональность.</div>\r\n<div><strong>Недостатки:</strong></div>\r\n<div>&mdash; Снижение производительности.</div>\r\n</div>",
      "lesson": 9,
      "ordering_number": 12,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 31,
    "fields": {
      "name": "6. В чем отличие итератора от генератора?",
      "content": "<p>Отличие генератора от итератора заключается в том, что итератор&nbsp;<strong>используется для обхода коллекции (например, списка) до тех пор, пока все элементы не будут перебраны, а генератор используется для создания последовательности значений</strong>.<br>&nbsp;Итераторы также могут быть созданы как классы, которые реализуют методы iter () и next (),<br>&nbsp;в то время как генераторы создаются при помощи функций и используют ключевое слово yield.<br><br>Генератор же генерирует значения. При этом, значения возвращаются по запросу и после возврата одного значения, выполнение функции-генератора приостанавливается до запроса следующего значения.</p>",
      "lesson": 9,
      "ordering_number": 13,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 32,
    "fields": {
      "name": "7. Какие методы могут быть реализованы в контекст-менеджере?",
      "content": "<div><strong>В контекстном менеджере в Python могут быть реализованы следующие методы:</strong></div>\r\n<ol>\r\n<li><strong>enter</strong>() &mdash; устанавливает контекст и может возвращать некоторый объект.</li>\r\n<li><strong>exit</strong>() &mdash; очищает объект.</li>\r\n</ol>\r\n<div>Если класс поддерживает протокол контекстного менеджера, ему необходимо реализовать эти два метода.</div>\r\n<div>&nbsp;</div>\r\n<div>они упрощают управление ресурсами&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Контекстные менеджеры являются удобным инструментом в Python для управления ресурсами, такими как<br>- файлы,<br>- сетевые соединения<br>- и другими объектами, которым требуется освобождение после использования.</div>\r\n<div>&nbsp;Они упрощают код и обеспечивают лучшее управление исключениями.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Контекстный менеджер в Python &mdash; это объект, который определяет методы&nbsp;<code>__enter__()</code>&nbsp;и&nbsp;<code>__exit__()</code>&nbsp;и используется с инструкцией&nbsp;<code>with</code>. Вот пример использования контекстного менеджера для работы с файлом:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>with&nbsp;</code><code>open</code><code>(</code><code>'file.txt'</code><code>,&nbsp;</code><code>'r'</code><code>) as&nbsp;</code><code>file</code><code>:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>data&nbsp;</code><code>=</code>&nbsp;<code>file</code><code>.read()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code># действия с данными</code></div>\r\n<div>&nbsp;</div>\r\n<div><code># здесь файл уже закрыт</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере контекстный менеджер открывает файл и автоматически закрывает его после выполнения блока кода внутри&nbsp;<code>with</code>.</div>\r\n<h2>Создание собственного контекстного менеджера</h2>\r\n<div>Вы также можете создать свой собственный контекстный менеджер, определив класс с методами&nbsp;<code>__enter__()</code>&nbsp;и&nbsp;<code>__exit__()</code>. Вот пример создания контекстного менеджера для измерения времени выполнения кода:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n<div>9</div>\r\n<div>10</div>\r\n<div>11</div>\r\n<div>12</div>\r\n<div>13</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>import</code>&nbsp;<code>time</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>class</code>&nbsp;<code>Timer:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>__enter__(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>self</code><code>.start&nbsp;</code><code>=</code>&nbsp;<code>time.time()</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>__exit__(</code><code>self</code><code>, exc_type, exc_val, exc_tb):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>self</code><code>.end&nbsp;</code><code>=</code>&nbsp;<code>time.time()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'Время выполнения: {self.end - self.start:.2f} секунд'</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>with Timer():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code># код, время выполнения которого нужно измерить</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>time.sleep(</code><code>2</code><code>)</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере метод&nbsp;<code>__enter__()</code>&nbsp;фиксирует время начала, а метод&nbsp;<code>__exit__()</code>&nbsp;вычисляет и выводит продолжительность выполнения кода внутри блока&nbsp;<code>with</code>.</div>\r\n<div>😉 Совет: Метод&nbsp;<code>__exit__()</code>&nbsp;принимает три аргумента, которые содержат информацию об исключении, если оно возникло внутри блока&nbsp;<code>with</code>. Вы можете использовать эту информацию для обработки исключений.</div>\r\n</div>",
      "lesson": 9,
      "ordering_number": 14,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 33,
    "fields": {
      "name": "8. Расскажи о разнице между компилятором и интерпретатором? Что работает быстрее?",
      "content": "<p>Компиляция&nbsp;<strong>работает</strong>&nbsp;<strong>быстрее</strong>&nbsp;интерпретации, потому что&nbsp;<strong>компилятор</strong>&nbsp;запускается только один раз: делает перевод и отдает его процессору.&nbsp;<strong>Интерпретатор</strong>&nbsp;же запускается на каждой строке кода и нужен при каждом запуске программы. Кроме того, программный код в&nbsp;<strong>компиляторе</strong>&nbsp;уже переведен в машинный, поэтому требуется намного меньше времени для его исполнения.<br><br></p>\r\n<h2>Как работает Python: интерпретатор и байт-код</h2>\r\n<div>Python часто называют интерпретируемым языком, но это не совсем точное определение. Когда вы запускаете Python-скрипт, интерпретатор Python сначала компилирует исходный код в промежуточный байт-код. Этот байт-код затем исполняется виртуальной машиной Python (PVM).</div>\r\n<h3>Процесс выполнения Python-кода</h3>\r\n<div>Процесс выглядит следующим образом:</div>\r\n<ol>\r\n<li>Исходный код (.py файл) компилируется в байт-код (.pyc файл).</li>\r\n<li>Байт-код исполняется виртуальной машиной Python.</li>\r\n</ol>\r\n<div>Этот процесс компиляции в байт-код происходит автоматически и прозрачно для пользователя. Это позволяет Python сочетать преимущества как интерпретируемых, так и компилируемых языков. Компиляция в байт-код делает выполнение кода более эффективным, так как байт-код ближе к машинным инструкциям, чем исходный код на высокоуровневом языке.</div>\r\n<h3>Преимущества и недостатки байт-кода</h3>\r\n<div>Использование байт-кода имеет свои преимущества и недостатки. С одной стороны, байт-код позволяет ускорить выполнение программ по сравнению с чисто интерпретируемыми языками. С другой стороны, байт-код все еще требует интерпретации виртуальной машиной, что может быть медленнее, чем выполнение скомпилированного машинного кода.</div>\r\n<h2>Python и компиляция: роль JIT-компиляции</h2>\r\n<div>Хотя стандартный интерпретатор Python (CPython) использует байт-код, существуют реализации Python, которые используют Just-In-Time (JIT) компиляцию. Например, PyPy &mdash; это альтернативная реализация Python, которая использует JIT-компиляцию для ускорения выполнения кода.</div>\r\n<h3>Что такое JIT-компиляция?</h3>\r\n<div>JIT-компиляция компилирует байт-код в машинный код \"на лету\" во время выполнения программы. Это может значительно повысить производительность, особенно для долгоживущих программ и циклов. JIT-компилятор анализирует выполнение программы и оптимизирует наиболее часто исполняемые участки кода, что позволяет достичь высокой производительности.</div>\r\n<h3>Примеры использования JIT-компиляции</h3>\r\n<div>PyPy является ярким примером использования JIT-компиляции в Python. PyPy может значительно ускорить выполнение Python-кода, особенно в случаях, когда программа выполняет множество вычислений или работает с большими объемами данных. Другие языки, такие как Java и JavaScript, также активно используют JIT-компиляцию для повышения производительности.</div>",
      "lesson": 9,
      "ordering_number": 15,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 34,
    "fields": {
      "name": "9. Что из себя представляют hash таблицы?",
      "content": "<p>Хэш-таблицы &mdash; это одна из самых эффективных и широко используемых структур данных в программировании. Они позволяют быстро находить, добавлять и удалять элементы, что делает их идеальными для множества задач. В Python хэш-таблицы реализованы через встроенный тип данных&nbsp;<code>dict</code>, который является одним из самых мощных инструментов языка.<br><br><br></p>\r\n<div>Хэш-таблица использует хэш-функцию для преобразования ключа в индекс массива, где хранится значение. Этот процесс включает несколько ключевых шагов:</div>\r\n<ol>\r\n<li><strong>Хэширование ключа</strong>: Хэш-функция принимает ключ и возвращает уникальное числовое значение (хэш). Это значение используется для определения индекса в массиве.</li>\r\n<li><strong>Определение индекса</strong>: Хэш используется для определения индекса в массиве, где будет храниться значение. Индекс обычно вычисляется как остаток от деления хэша на размер массива.</li>\r\n<li><strong>Разрешение коллизий</strong>: Если два ключа имеют одинаковый хэш, используется метод разрешения коллизий, например, цепочки или открытая адресация.</li>\r\n</ol>\r\n<h3>Пример хэш-функции</h3>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code>def simple_hash(key):\r\n    return sum(ord(char) for char in key) % 10</code></pre>\r\n</div>\r\n</div>\r\n<div>В этом примере хэш-функция берет строку, суммирует ASCII-коды всех символов и берет остаток от деления на 10. Это простой, но эффективный способ преобразования строки в числовое значение.</div>\r\n<h3>Разрешение коллизий</h3>\r\n<div>Коллизии неизбежны, поэтому важно понимать методы их разрешения. Существует несколько популярных методов:</div>\r\n<ul>\r\n<li><strong>Цепочки (Chaining)</strong>: Каждый индекс массива содержит связанный список всех элементов, имеющих одинаковый хэш. Это позволяет хранить несколько элементов в одном индексе.</li>\r\n<li><strong>Открытая адресация (Open Addressing)</strong>: При коллизии ищется следующий свободный индекс в массиве. Этот метод включает несколько стратегий, таких как линейное пробирование, квадратичное пробирование и двойное хэширование.</li>\r\n</ul>\r\n<p>Линейное пробирование</p>\r\n<div>Линейное пробирование &mdash; это метод открытой адресации, при котором при коллизии мы просто переходим к следующему индексу в массиве. Если и там есть элемент, переходим к следующему и так далее, пока не найдем свободный индекс.</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code>def linear_probing(hash_table, key, value):\r\n    index = simple_hash(key)\r\n    while hash_table[index] is not None:\r\n        index = (index + 1) % len(hash_table)\r\n    hash_table[index] = (key, value)</code></pre>\r\n</div>\r\n</div>\r\n<p>Квадратичное пробирование</p>\r\n<div>Квадратичное пробирование использует квадратичную функцию для определения следующего индекса при коллизии. Это помогает уменьшить кластеризацию элементов.</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code>def quadratic_probing(hash_table, key, value):\r\n    index = simple_hash(key)\r\n    i = 1\r\n    while hash_table[index] is not None:\r\n        index = (index + i**2) % len(hash_table)\r\n        i += 1\r\n    hash_table[index] = (key, value)</code></pre>\r\n</div>\r\n</div>\r\n<h2>Применение хэш-таблиц в Python</h2>\r\n<div>В Python хэш-таблицы реализованы через тип данных&nbsp;<code>dict</code>. Они обеспечивают быстрый доступ к данным за счет использования хэш-функций. Давайте рассмотрим, как можно создавать и использовать словари в Python.</div>\r\n<h3>Создание и использование словаря</h3>\r\n<div>Создание словаря в Python очень просто. Вы можете использовать фигурные скобки&nbsp;<code>{}</code>&nbsp;или функцию&nbsp;<code>dict()</code>.</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code># Создание словаря\r\nmy_dict = {}\r\n\r\n# Добавление элементов\r\nmy_dict['apple'] = 1\r\nmy_dict['banana'] = 2\r\n\r\n# Доступ к элементам\r\nprint(my_dict['apple'])  # Вывод: 1\r\n\r\n# Удаление элементов\r\ndel my_dict['banana']</code></pre>\r\n</div>\r\n</div>\r\n<h3>Встроенные методы словаря</h3>\r\n<div>Python предоставляет множество встроенных методов для работы со словарями, что делает их использование еще более удобным.</div>\r\n<ul>\r\n<li><strong><code>keys()</code></strong>: Возвращает все ключи в словаре.</li>\r\n<li><strong><code>values()</code></strong>: Возвращает все значения в словаре.</li>\r\n<li><strong><code>items()</code></strong>: Возвращает все пары ключ-значение в словаре.</li>\r\n<li><strong><code>get(key, default)</code></strong>: Возвращает значение по ключу, если ключ не найден, возвращает значение по умолчанию.</li>\r\n</ul>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code># Примеры использования методов словаря\r\nprint(my_dict.keys())    # Вывод: dict_keys(['apple'])\r\nprint(my_dict.values())  # Вывод: dict_values([1])\r\nprint(my_dict.items())   # Вывод: dict_items([('apple', 1)])\r\nprint(my_dict.get('banana', 'Not Found'))  # Вывод: Not Found</code></pre>\r\n</div>\r\n</div>\r\n<h3>Преимущества использования хэш-таблиц</h3>\r\n<div>Хэш-таблицы обладают рядом преимуществ, которые делают их незаменимыми в программировании:</div>\r\n<ul>\r\n<li><strong>Быстрый доступ</strong>: Время доступа к элементу в среднем O(1), что делает хэш-таблицы очень эффективными для поиска и вставки данных.</li>\r\n<li><strong>Гибкость</strong>: Поддержка различных типов данных в качестве ключей и значений. Вы можете использовать строки, числа и даже кортежи в качестве ключей.</li>\r\n<li><strong>Простота использования</strong>: Встроенные методы для работы с данными делают хэш-таблицы легкими в использовании и управлении.</li>\r\n</ul>\r\n<h2>&nbsp;</h2>",
      "lesson": 9,
      "ordering_number": 16,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 35,
    "fields": {
      "name": "10. В чем отличие списков от множеств?",
      "content": "<div><strong>Список в Python</strong>&nbsp;&mdash; это упорядоченный набор элементов, перечисленных через запятую, заключённый в квадратные скобки.</div>\r\n<div><strong>Список отличается от множества (set) следующими особенностями:</strong></div>\r\n<ol>\r\n<li>Список может содержать одинаковые элементы, в отличие от множества.</li>\r\n<li>Список упорядочен: каждый элемент списка имеет индекс, а элемент множества &mdash; нет.</li>\r\n<li>Проверка, принадлежит ли элемент множеству, выполняется быстрее, чем такая же проверка элемента списка.</li>\r\n</ol>\r\n<div>\r\n<h3>Создание списков</h3>\r\n<div>Создание списков в Python очень просто и интуитивно понятно. Вы можете создать пустой список или список с элементами, указав их в квадратных скобках.</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code># Создание пустого списка\r\nempty_list = []\r\n\r\n# Создание списка с элементами\r\nnumbers = [1, 2, 3, 4, 5]\r\nfruits = [\"apple\", \"banana\", \"cherry\"]</code></pre>\r\n<pre><code>&nbsp;</code></pre>\r\n<pre><code>&nbsp;</code></pre>\r\n<pre>&nbsp;</pre>\r\n<h3>Создание кортежей</h3>\r\n<pre>&nbsp;</pre>\r\n<div>Создание кортежей в Python также очень просто. Вы можете создать пустой кортеж или кортеж с элементами, указав их в круглых скобках.</div>\r\n<pre>&nbsp;</pre>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code># Создание пустого кортежа\r\nempty_tuple = ()\r\n\r\n# Создание кортежа с элементами\r\nnumbers_tuple = (1, 2, 3, 4, 5)\r\nfruits_tuple = (\"apple\", \"banana\", \"cherry\")</code></pre>\r\n<pre><code>&nbsp;</code></pre>\r\n<pre>&nbsp;</pre>\r\n<h3>Создание множеств</h3>\r\n<pre>&nbsp;</pre>\r\n<div>Создание множеств в Python также очень просто. Вы можете создать пустое множество или множество с элементами, указав их в фигурных скобках&nbsp;<code>{}</code>&nbsp;или с помощью функции&nbsp;<code>set()</code>.</div>\r\n<pre>&nbsp;</pre>\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Python</div>\r\n<div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>Скопировать код</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<pre><code># Создание пустого множества\r\nempty_set = set()\r\n\r\n# Создание множества с элементами\r\nnumbers_set = {1, 2, 3, 4, 5}\r\nfruits_set = {\"apple\", \"banana\", \"cherry\"}</code></pre>\r\n</div>\r\n</div>\r\n<pre>&nbsp;</pre>\r\n</div>\r\n</div>\r\n<pre>&nbsp;</pre>\r\n</div>\r\n</div>\r\n</div>",
      "lesson": 9,
      "ordering_number": 17,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 36,
    "fields": {
      "name": "11. К каким типам данных относятся числа и строки?",
      "content": "<div><strong>Какие</strong>&nbsp;<strong>типы</strong>&nbsp;<strong>данных</strong>&nbsp;в&nbsp;<strong>Python</strong>&nbsp;не изменяются?</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Неизменяемые типы данных</div>\r\n<div>Числовые (int, float, complex)</div>\r\n<div>Логический (bool)</div>\r\n<div>Строки (str) нельзя менять отдельные буквы в строке &mdash; только создав новую строку</div>\r\n<div>Кортеж (tuple) не позволяет изменять набор, но может содержать изменяемые элементы</div>\r\n<div>Замороженное множество (frozenset)</div>\r\n<div>Функции имя функции также является переменной, и может быть переопределено</div>\r\n<div>Классы но не экземпляры классов</div>\r\n</div>\r\n</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div><strong>Какие</strong>&nbsp;<strong>типы</strong>&nbsp;<strong>данных</strong>&nbsp;в&nbsp;<strong>питоне</strong>&nbsp;<strong>изменяемые</strong>?</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>К&nbsp;<strong>изменяемым</strong>&nbsp;<strong>типам</strong>&nbsp;<strong>данных</strong>&nbsp;относят set, list, dict. Переменные&nbsp;<strong>изменяемых</strong>&nbsp;<strong>типов</strong>&nbsp;<strong>данных</strong>&nbsp;могут&nbsp;<strong>изменить</strong>&nbsp;своё значение без создания новой переменной с тем же именем. При этом у переменной сохранится тот же идентификатор. Для этого можно воспользоваться операциями и методами, которые&nbsp;<strong>меняют</strong> значения в коллекции.</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>",
      "lesson": 10,
      "ordering_number": 1,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 37,
    "fields": {
      "name": "12. Дай определение термину Объектно-ориентированное",
      "content": "<div><strong>О</strong><strong>бъектно-ориентированное программирование (ООП)</strong>&nbsp;&mdash; это подход разработки, при котором программу создают из объектов, взаимодействующих друг с другом.</div>\r\n<div>Объекты &mdash; это самостоятельные части программы, внутри которых код и данные обрабатываются вместе, образуя целый собственный мир. Это полноценные блоки с информацией, которые отвечают только за себя и имеют некоторый набор характеристик и возможностей.</div>\r\n<div>Структура и поведение объектов определяются классом, которому они принадлежат.</div>",
      "lesson": 10,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 38,
    "fields": {
      "name": "13. Назови 4 основных принципа ООП",
      "content": "<div><strong>В объектно-ориентированном программировании (ООП) выделяют 4 основных принципа:</strong></div>\r\n<ol>\r\n<li><strong>Абстракция</strong>&nbsp;&mdash; выделение основных, наиболее значимых характеристик объекта с последующим игнорированием второстепенных.</li>\r\n<li><strong>Полиморфизм</strong>&nbsp;&mdash; возможность нескольких реализаций в пределах одной и той же идеи.</li>\r\n<li><strong>Наследование</strong>&nbsp;&mdash; способность класса расширять понятие другого класса. Главный механизм повторного использования кода в ООП.</li>\r\n<li><strong>Инкапсуляция</strong> &mdash; принцип, позволяющий обеспечивать безопасность и управление сложностью кодификации. Он блокирует доступ к деталям сложных концепций.</li>\r\n</ol>",
      "lesson": 10,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 39,
    "fields": {
      "name": "14. Что нужно сделать, чтобы класс преобразовать в декоратор?",
      "content": "<div>Декоратор класса &mdash; это функция, которая принимает класс в качестве аргумента и возвращает новый класс с модифицированными или расширенными свойствами и методами. Декораторы классов позволяют изменять поведение класса без изменения его исходного кода.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Чтобы класс преобразовать в декоратор в Python, нужно&nbsp;<strong>добавить в него метод&nbsp;call</strong>, который сделает экземпляр класса вызываемым.&nbsp;</div>\r\n<div><strong>Отличие в том, что класс инициализируется при объявлении</strong>. Он должен получить функцию в качестве аргумента для метода&nbsp;<strong>init</strong>.</div>\r\n<div>&nbsp;Это и будет декорируемая функция.&nbsp;</div>\r\n<div><strong>При вызове декорируемой функции на самом деле вызывается экземпляр класса</strong>. А поскольку объект вызываемый, то вызывается функция&nbsp;<strong>call</strong>.&nbsp;</div>\r\n<div><strong>Пример класса-декоратора</strong>:</div>\r\n<div>&nbsp;</div>\r\n<div>class Decorator:<br>&nbsp; def __init__(self, func):<br>&nbsp;&nbsp;&nbsp; self.func = func<br>&nbsp; def __call__(self):<br>&nbsp;&nbsp;&nbsp; self.func()<br>&nbsp; print('&gt; после вызова класса')&nbsp;[1](https://PythonRu.com/osnovy/rukovodstvo-po-dekoratoram-python)</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Давайте рассмотрим пример простого декоратора класса, который добавляет новый метод к классу:<br><br><br>def add_new_method(class_to_decorate):<br>&nbsp;&nbsp;&nbsp; class DecoratedClass(class_to_decorate):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def new_method(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return \"This is a new method\"<br>&nbsp;&nbsp;&nbsp; return DecoratedClass<br><br>@add_new_method<br>class MyClass:<br>&nbsp;&nbsp;&nbsp; def my_method(self):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return \"This is my method\"<br><br>my_object = MyClass()<br>print(my_object.my_method())&nbsp; # вывод: This is my method<br>print(my_object.new_method())&nbsp; # вывод: This is a new method<br><br>В этом примере мы создали декоратор add_new_method, который принимает класс и возвращает новый класс DecoratedClass с добавленным методом new_method. Затем мы применили этот декоратор к классу MyClass с помощью синтаксиса @add_new_method.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<h2>Что нужно запомнить</h2>\r\n<ul>\r\n<li>Вызываемые классы можно использовать в качестве декораторов, реализовав метод&nbsp;<code>__call__</code>.</li>\r\n<li>Аргументы декоратора передаются в метод&nbsp;<code>__init__</code></li>\r\n</ul>\r\n</div>\r\n<div>&nbsp;</div>",
      "lesson": 10,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 40,
    "fields": {
      "name": "15. SQLite и PostgeSQL: Что это, и чем отличается?",
      "content": "<div>\r\n<div>SQLite и PostgreSQL &mdash; это два разных типа систем управления реляционными базами данных с разной архитектурой и вариантами использования. Основные различия между ними кратко изложены ниже:</div>\r\n<ol>\r\n<li><strong>Архитектура:</strong><br>SQLite &mdash; это бессерверная система управления базами данных, которую можно встроить непосредственно в приложение, а PostgreSQL &mdash; это система управления базами данных клиент-сервер, для которой на компьютере должен быть запущен отдельный серверный процесс для обработки запросов к базе данных.</li>\r\n<li><strong>Масштабируемость</strong>&nbsp;:<br>SQLite предназначен для использования на одной машине и не подходит для крупномасштабных развертываний или приложений с высоким трафиком. PostgreSQL, с другой стороны, предназначен для горизонтального и вертикального масштабирования, что означает, что он может обрабатывать большие объемы данных и трафика за счет добавления большего количества серверов в кластер, а также за счет увеличения ресурсов одного сервера.</li>\r\n<li><strong>Типы данных:</strong><br>PostgreSQL поддерживает более широкий спектр типов данных, включая массивы, hstore и json, тогда как SQLite имеет ограниченный набор типов данных.</li>\r\n<li><strong>Соответствие SQL.</strong><br>И SQLite, и PostgreSQL совместимы с SQL, но PostgreSQL поддерживает более широкий спектр команд и функций SQL, что делает его более подходящим для сложных запросов и больших наборов данных.</li>\r\n<li><strong>Соответствие ACID.</strong><br>И SQLite, и PostgreSQL совместимы с ACID, что означает, что они обеспечивают целостность и согласованность данных в транзакциях. Однако PostgreSQL поддерживает более сложные транзакции и обеспечивает более надежную модель параллелизма.</li>\r\n<li><strong>Лицензирование</strong>&nbsp;:<br>SQLite находится в свободном доступе и может использоваться без каких-либо лицензионных ограничений, в то время как PostgreSQL лицензируется по лицензии PostgreSQL, которая является либеральной лицензией с открытым исходным кодом.</li>\r\n</ol>\r\n<div>Подводя итог, SQLite и PostgreSQL &mdash; это два разных типа систем управления реляционными базами данных с разной архитектурой и вариантами использования. SQLite &mdash; это легкая бессерверная база данных, предназначенная для небольших приложений, которым требуется простота и удобство использования, а PostgreSQL &mdash; мощная база данных клиент-сервер, предназначенная для высокопроизводительных крупномасштабных развертываний, требующих сложных запросов и типов данных.</div>\r\n</div>\r\n<p>Таким образом,&nbsp;<strong>SQLite</strong>&nbsp;<strong>и</strong>&nbsp;<strong>PostgreSQL</strong>&nbsp;-&nbsp;<strong>это</strong>&nbsp;два разных типа систем управления реляционными базами данных с разными архитектурами и вариантами использования.&nbsp;<strong>SQLite</strong>&nbsp;-&nbsp;<strong>это</strong>&nbsp;легкая бессерверная база данных, предназначенная для небольших приложений, которым требуется простота и непринужденность в использовании, в то время как&nbsp;<strong>PostgreSQL</strong>&nbsp;-&nbsp;<strong>это</strong> мощная клиент-серверная база данных, предназначенная для высокопроизводительных крупномасштабных развертываний, требующих сложных запросов и типов данных.</p>",
      "lesson": 10,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 41,
    "fields": {
      "name": "16. Какие типы данных существуют в Python и как их можно классифицировать",
      "content": "<div><strong>Неизменяемые</strong>&nbsp;встроенные типы:</div>\r\n<ul>\r\n<li><code>int</code>&nbsp;&mdash; целое число,</li>\r\n<li><code>float</code>&nbsp;&mdash; число с плавающей точкой,</li>\r\n<li><code>complex</code>&nbsp;&mdash; комплексное число,</li>\r\n<li><code>bool</code>&nbsp;&mdash; логическое значение,</li>\r\n<li><code>NoneType</code>&nbsp;&mdash; тип для единственного объекта-синглтона: неопределенного значения&nbsp;<code>None</code>,</li>\r\n<li><code>str</code>&nbsp;&mdash; строка,</li>\r\n<li><code>tuple</code>&nbsp;&mdash; кортеж,</li>\r\n<li><code>range</code>&nbsp;&mdash; неизменяемая последовательность чисел,</li>\r\n<li><code>frozenset</code>&nbsp;&mdash; неизменяемое множество,</li>\r\n<li><code>bytes</code>&nbsp;&mdash; неизменяемая последовательность байтов.</li>\r\n</ul>\r\n<div><strong>Изменяемые</strong>&nbsp;встроенные типы:</div>\r\n<ul>\r\n<li><code>list</code>&nbsp;&mdash; список,</li>\r\n<li><code>set</code>&nbsp;&mdash; множество,</li>\r\n<li><code>dict</code>&mdash; словарь.</li>\r\n<li><code>bytearray</code>&nbsp;&mdash; изменяемая последовательность байтов.</li>\r\n<li><code>memoryview</code>&nbsp;&mdash; &laquo;окно&raquo; на некую область в памяти, через которое ее можно читать и модифицировать. Тип&nbsp;<code>memoryview</code>&nbsp;умеет работать с двумя встроенными типами:&nbsp;<code>bytes</code>&nbsp;и&nbsp;<code>bytearray</code>.</li>\r\n</ul>",
      "lesson": 10,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 42,
    "fields": {
      "name": "17. Какие типы аргументов существуют у функции?",
      "content": "<p>Позиционные&nbsp;аргументы&nbsp;- это основной тип&nbsp;аргументов&nbsp;в&nbsp;Python.<br>&nbsp;Когда вы вызываете функцию и передаете&nbsp;аргументы&nbsp;без указания их имен,&nbsp;Python&nbsp;сопоставляет&nbsp;аргументы&nbsp;на основе их позиций. Порядок&nbsp;аргументов&nbsp;должен соответствовать порядку параметров, определенных в определении функции или сигнатуре функции.<br><br>В&nbsp;<strong>Python</strong>&nbsp;<strong>аргументы</strong>&nbsp;<strong>функции</strong>&nbsp;бывают двух&nbsp;<strong>видов</strong>&nbsp;&mdash; именованные и позиционные. Оба&nbsp;<strong>типа</strong>&nbsp;<strong>аргументов</strong>&nbsp;могут быть переменной длины.<br><br></p>",
      "lesson": 10,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 43,
    "fields": {
      "name": "18. Что такое срез и как его реализовать?",
      "content": "<div><strong>Срез (slice) &mdash; механизм, который позволяет выбирать определённую часть последовательности, такой как строка, список или кортеж.</strong></div>\r\n<div>Срезы формируются при помощи квадратных скобок &laquo;[]&raquo; и двоеточия &laquo;:&raquo;.</div>\r\n<div>Синтаксис среза выглядит так:</div>\r\n<div><code>i_object[start:stop:step]\r\n</code>Скопировать</div>\r\n<div>Где:</div>\r\n<ul>\r\n<li>i_object &mdash; это итерируемый объект (последовательность);</li>\r\n<li>start &mdash; индекс начала среза;</li>\r\n<li>stop &mdash; индекс окончания среза;</li>\r\n<li>step &mdash; шаг.</li>\r\n</ul>\r\n<div>Срез в Python не изменяет исходный итерируемый объект, а создаёт новый объект, содержащий выбранные элементы исходного объекта. При этом исходный объект остаётся неизменным.</div>\r\n<div>С помощью срезов можно:</div>\r\n<ul>\r\n<li>извлекать подстроки из строк;</li>\r\n<li>извлекать подмножества из списков;</li>\r\n<li>производить другие операции над последовательностями.</li>\r\n</ul>\r\n<div>&nbsp;</div>\r\n<div>\r\n<h3>Отрицательные индексы</h3>\r\n<div>Отрицательные индексы позволяют работать с итерируемыми объектами в обратном порядке:</div>\r\n</div>",
      "lesson": 10,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 44,
    "fields": {
      "name": "19. Дай определение понятию \"функция\"",
      "content": "<div><strong>Функция в Python &mdash; это именованный фрагмент программного кода, к которому можно обратиться из другого места программы.</strong></div>\r\n<div>Как правило, функции создаются для работы с данными, которые передаются ей в качестве аргументов. Также функция может формировать некоторое возвращаемое значение.</div>\r\n<div>Для создания функции используется ключевое слово&nbsp;\r\n<pre>def</pre>\r\n, после которого указывается имя и список аргументов в круглых скобках. Тело функции выделяется четырьмя пробелами.</div>\r\n<div>Возврат значения функцией осуществляется с помощью ключевого слова&nbsp;\r\n<pre>return</pre>\r\n, после которого указывается возвращаемое значение.</div>",
      "lesson": 10,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 45,
    "fields": {
      "name": "20. Что такое \"лямбда-функции\"?",
      "content": "<div><strong>Лямбда-функции в Python &mdash; это функции, которые не имеют названия.</strong>&nbsp;Их также называют анонимными. Слово &laquo;lambda&raquo; является служебным и не отражает сути конкретной функции.</div>\r\n<div>Основная причина применения лямбда-функций &mdash; создание функции, которая используется в коде единожды. Использование таких функций позволяет снизить число строк кода, которые придётся написать.</div>\r\n<div>Создание лямбда-функций происходит с помощью ключевого слова lambda следующим образом:</div>\r\n<div>\r\n<pre>lambda &lt;аргумент(ы)&gt;: &lt;выражение&gt;</pre>\r\n</div>\r\n<div>Лямбда-функции могут иметь сколько угодно аргументов или не иметь их вовсе, но обязательно должны содержать лишь одно выражение.</div>",
      "lesson": 10,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 46,
    "fields": {
      "name": "21. Как реализуется полиморфизм?",
      "content": "<div>Если говорить буквально, то слово polymorphism означает &laquo;множество форм&raquo;.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;Так и код в программировании &mdash; благодаря использованию вышеупомянутого принципа ООП, код становится более гибким, ведь на практике разработчик получает возможность использовать одну и ту же сущность (method, оператор либо объект) для представления разных типов в разных сценариях.</div>\r\n<h2>Пример № 1</h2>\r\n<div>Хорошо известно, что оператор &ldquo;+&rdquo;&nbsp;нередко применяют в программах, написанных на Python. Но использовать этот оператор можно по-разному.</div>\r\n<div>Если мы говорим о целочисленных типах данных, то мы применяем &ldquo;+&rdquo; в целях сложения операндов:</div>\r\n<pre><code>number1 = 1\r\nnumber2 = 2\r\nprint(number1 + number2)</code></pre>\r\n<div>Такая программа выведет на экран цифру 3. Элементарно, Ватсон!</div>\r\n<div>Однако применять &ldquo;+&rdquo; можно и для конкатенации строк:</div>\r\n<pre><code>string1 = \"Hello,\"\r\nstring2 = \"Otus!\"\r\nprint(string1+\" \"+string2)</code></pre>\r\n<div>Результат очевиден и здесь:</div>\r\n<div><code>Hello Otus!</code></div>\r\n<div>Какой же вывод можно сделать из вышесказанного? У нас существует единственный оператор&nbsp;&ldquo;+&rdquo;, который способен&nbsp;выполнять&nbsp;<strong>разные операции для разных типов данных</strong>. Это является одним из наиболее простых примеров полиморфизма на &laquo;Пайтон&raquo;.</div>\r\n<h2>Пример № 2</h2>\r\n<div>В языке Python существуют функции, способные принимать аргументы различных типов. Пример такой функции &mdash;&nbsp;<code>len()</code>. Она способна принимать разные типы данных. Работает это следующим образом:</div>\r\n<pre><code>print(len(\"ООП-программирование\"))\r\nprint(len([\"Python\", \"Java\", \"C#\", \"Scala\", \"C++\"]))\r\nprint(len({\"Где изучить?\": \"В Otus\", \"Как проходят занятия?\": \"Онлайн\"}))</code></pre>\r\n<div>Вывод будет необычен, но если разобраться, то все просто:</div>\r\n<pre><code>20\r\n 5\r\n 2</code></pre>\r\n<div>Причина в том, что функция&nbsp;<code>len()</code>&nbsp;может работать с разными типами данных: строкой, списком, кортежем, множеством, словарем. В результате в нашем случае одна и та же функция каждый раз возвратила специфичную информацию для каждого типа данных:</div>\r\n<ul>\r\n<li>посчитала количество букв в слове &laquo;Программирование&raquo;;</li>\r\n<li>посчитала количество слов в списке;</li>\r\n<li>посчитала количество ключей в словаре.</li>\r\n</ul>\r\n<p><img src=\"http://127.0.0.1:55104/1-1024x637.png\" alt=\"Полиморфизм в &laquo;Пайтон&raquo;\" width=\"525\"></p>\r\n<h2>Пример № 3</h2>\r\n<div>Так как различные классы в &laquo;Питоне&raquo; способны иметь методы с одинаковым именем, то идея вполне подходит и для методов базового класса. Позже мы обобщим вызов данных методов и проигнорируем объект, с которым работаем.</div>\r\n<div>Ниже &mdash; пример такого полиморфизма в методах класса:</div>\r\n<p><img src=\"http://127.0.0.1:55104/3-fdf4b391a004a213ea00e1837ac87cbcbeee86a0.png\" alt=\"Полиморфизм в &laquo;Пайтон&raquo;\" width=\"741\"></p>\r\n<div>Смотрим вывод в консоль:</div>\r\n<pre><code>Мяу!\r\nЯ кот. Меня зовут Васька. Мне 2 года.\r\nМяу!\r\nГав!\r\nЯ собака. Меня зовут Мухтар. Мне 3 года.\r\nГав!</code></pre>\r\n<div>У нас создано 2 класса:&nbsp;<strong>Cat&nbsp;</strong>и&nbsp;<strong>Dog</strong>. У этих классов структура похожа, плюс они имеют методы с одинаковыми именами:</div>\r\n<ul>\r\n<li><code>make_sound()</code>;</li>\r\n<li><code>info()</code>.</li>\r\n</ul>\r\n<div>Но стоит отметить, что нам не пришлось создавать общий класс-родитель, как и не пришлось соединять эти классы вместе каким-нибудь иным методом. Для обоих случаев у нас используется общая переменная&nbsp;<code>animal</code>, что стало возможным благодаря наличию полиморфизма.</div>\r\n<h2>Пример № 4</h2>\r\n<div>Как и в прочих языках программирования, в &laquo;Питоне&raquo; классы-потомки способны выполнять наследование методов и атрибутов родительского класса. То есть у нас существует возможность переопределить ряд methods и attributes, сделав это для того, чтобы они соответствовали классу-потомку. Данное поведение называют&nbsp;<strong>переопределением (overriding)</strong>. И благодаря наличию полиморфизма мы можем получать доступ к переопределенным methods и attributes, имеющим такое же имя, как и в parent class.</div>\r\n<div>Пример такого переопределения ниже:</div>\r\n<pre><code>from math import pi\r\nclass Shape:\r\n    def __init__(self, name):\r\n        self.name = name\r\n    def area(self):\r\n        pass\r\n    def fact(self):\r\n        return \"Я - двумерная фигура\"\r\n    def __str__(self):\r\n        return self.name\r\nclass Square(Shape):\r\n    def __init__(self, length):\r\n        super().__init__(\"Квадрат\")\r\n        self.length = length\r\n    def area(self):\r\n        return self.length**2\r\n    def fact(self):\r\n        return \"Любой угол квадрата равен 90 градусов.\"\r\nclass Circle(Shape):\r\n    def __init__(self, radius):\r\n        super().__init__(\"Круг\")\r\n        self.radius = radius\r\n    def area(self):\r\n        return pi*self.radius**2\r\na = Square(5)\r\nb = Circle(8)\r\nprint(b)\r\nprint(b.fact())\r\nprint(a.fact())\r\nprint(b.area())</code></pre>\r\n<div>Смотрим на вывод программы:</div>\r\n<pre><code>Круг\r\nЯ - двумерная фигура\r\nЛюбой угол квадрата равняется 90 градусам.\r\n201.06192982974676</code></pre>\r\n<div>В работе кода мы использовали методы&nbsp;<code>__str__()</code>&nbsp;&mdash; они не были переопределены в дочерних классах и применяются непосредственно из класса-родителя. То есть интерпретатор &laquo;Пайтона&raquo; автоматически распознал, что метод&nbsp;<code>fact()</code>&nbsp;для объекта&nbsp;<code>a</code>&nbsp;(class&nbsp;Square) является переопределенным. В результате применяется тот метод, который был определен в классе-потомке.</div>\r\n<div>В это же самое время, метод&nbsp;<code>fact()</code>&nbsp;для объекта&nbsp;<code>b&nbsp;</code>переопределенным не является, в результате чего применяется метод с таким же именем из parent class (Shape).</div>\r\n<p><img src=\"http://127.0.0.1:55104/2.png\" alt=\"Полиморфизм в &laquo;Пайтон&raquo;\" width=\"746\"></p>\r\n<div>Важно отметить, что в &laquo;Питоне&raquo; не поддерживается такой вариант&nbsp;<strong>method overriding</strong>, как создание методов с тем же самым именем, однако с различными типами аргументов.</div>",
      "lesson": 14,
      "ordering_number": 1,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 47,
    "fields": {
      "name": "32. Как проводить анализ изменений и истории в Git",
      "content": "<div>Для анализа изменений и истории в Git можно использовать следующие команды:</div>\r\n<ol>\r\n<li><strong>Git log</strong>&nbsp;&mdash; показывает список всех выполненных коммитов, отсортированных по дате добавления.</li>\r\n<li><strong>Git show</strong>&nbsp;&mdash; позволяет посмотреть все изменения, сделанные в рамках одного коммита.</li>\r\n<li><strong>Git grep</strong>&nbsp;&mdash; ищет совпадение с указанной строкой во всех файлах проекта.</li>\r\n</ol>\r\n<div>Также можно анализировать проект на GitHub, который позволяет просматривать историю коммитов, изменения в конкретном коммите и многое другое.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>После внесения любых изменений в проект можно посмотреть статус файлов с помощью команды git status. Она покажет файлы, в которых были произведены изменения, удалённые и новые, требующие добавления.</div>\r\n<div>Чтобы добавить отслеживание новых файлов, необходимо использовать команду git add &lt;filename&gt; &lt;filename&gt; для добавления нескольких файлов по имени.</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Какая команда поможет узнать автора&nbsp;<strong>изменений</strong>&nbsp;<strong>в</strong>&nbsp;<strong>git</strong>?</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Для этого подойдет&nbsp;<strong>команда</strong>&nbsp;<strong>git</strong>&nbsp;blame &lt;путь до файла&gt;. Эта&nbsp;<strong>команда</strong>&nbsp;выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите.</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<p><br><br><br>Команда git diff показывает разницу между последним коммитом и текущим состоянием репозитория.<br><br>Последний коммит сравнивается со всеми неотслеживаемыми файлами, которые ещё не переведены в индекс.<br><br>Можно добавить имя файла и сравнить его содержимое с последним коммитом. Ещё вариант: вместо имени файла можно использовать хеш коммита.<br><br>Также можно добавить опцию --staged и сравнить версию кода после последнего коммита с отслеживаемым состоянием репозитория &mdash; со всеми файлами, которые находятся в индексе.</p>",
      "lesson": 15,
      "ordering_number": 1,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 48,
    "fields": {
      "name": "41. Что такое вложенные классы и где они применяются?",
      "content": "<div>В двух словах, это когда один класс объявлен внутри другого.&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;И здесь сразу возникает два главных вопроса:&nbsp;</div>\r\n<div>как это работает и зачем это надо?&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Я попробую дать ответ сразу на оба этих вопроса.</div>\r\n<div>&nbsp;</div>\r\n<div>На мой взгляд, хороший пример использования вложенных классов &ndash; это описание моделей во фреймворке Django. Если вы не знаете, что это такое, то не беспокойтесь, нам нужна будет только суть вложений. Итак, там часто можно встретить определения вида:</div>\r\n<div>\r\n<div>\r\n<pre>class Women:\r\n&nbsp;&nbsp;&nbsp; title = 'объект класса для поля title'\r\n&nbsp;&nbsp;&nbsp; photo = 'объект класса для поля photo'\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']</pre>\r\n</div>\r\n</div>\r\n<div>Здесь объявляется некий класс Women, далее прописаны два атрибута, которые в Django являются ссылками на определенные классы, но в нашем примере &ndash; это просто строки. Причем, атрибуты title и photo &ndash; это поля в таблице БД, с которой впоследствии идет работа, то есть, полагаем, что нам важно называть эти атрибуты именно такими именами. Затем, идет объявление вложенного класса Meta с одним атрибутом ordering. В Django с помощью такого класса Meta определяют некие вспомогательные параметры. В частности, параметр ordering определяет сортировку по полю id записей в таблице БД. Если вы ничего не поняли про записи и таблицы, то это не важно. Главное сейчас, что у нас есть класс Women, в нем атрибуты со строго определенными именами и вложенный класс Meta с одним атрибутом ordering. Это все, что нужно сейчас знать.</div>\r\n<div><img src=\"http://127.0.0.1:55104/image001.png\"></div>\r\n<div>Но все же, зачем нужен такой вложенный класс? Почему бы этот атрибут не прописать непосредственно в классе Women? Давайте предположим, что в нашей таблице есть поле с именем ordering и для работы с ним в классе Women его следует прописать, сделаем это так:</div>\r\n<div>\r\n<div>\r\n<pre>class Women:\r\n&nbsp;&nbsp;&nbsp; title = 'объект класса для поля title'\r\n&nbsp;&nbsp;&nbsp; photo = 'объект класса для поля photo'\r\n&nbsp;&nbsp;&nbsp; ordering = 'объект класса для поля ordering'\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']</pre>\r\n</div>\r\n</div>\r\n<div>Видите, если бы не было вложенного класса Meta, то возникла бы проблема с использованием одного и того же атрибута ordering для разных целей: и для представления данных поля ordering и для управления сортировкой. Вложенный класс Meta, фактически, создает независимое пространство имен для разрешения подобных конфликтов.</div>\r\n<div><img src=\"http://127.0.0.1:55104/image002.png\"></div>\r\n<div>Разумеется, мы можем совершенно спокойно обращаться ко всем атрибутам класса через основной класс Women, например, так:</div>\r\n<div>\r\n<div>\r\n<pre>print(Women.ordering)\r\nprint(Women.Meta.ordering)</pre>\r\n</div>\r\n</div>\r\n<div>В первом случае берем атрибут ordering непосредственно из класса Women, а во втором &ndash; из класса Meta.</div>\r\n<div>То же самое можно делать и через экземпляры класса Women:</div>\r\n<div>\r\n<div>\r\n<pre>w = Women()\r\nprint(w.ordering)\r\nprint(w.Meta.ordering)</pre>\r\n</div>\r\n</div>\r\n<div>Причем внутри самого объекта у нас сейчас не будет никаких локальных свойств:</div>\r\n<div>\r\n<div>\r\n<pre>print(w.__dict__)</pre>\r\n</div>\r\n</div>\r\n<div>Давайте для примера добавим инициализатор в класс Women, запишем его следующим образом:</div>\r\n<div>\r\n<div>\r\n<pre>class Women:\r\n&nbsp;&nbsp;&nbsp; title = 'объект класса для поля title'\r\n&nbsp;&nbsp;&nbsp; photo = 'объект класса для поля photo'\r\n&nbsp;&nbsp;&nbsp; ordering = 'объект класса для поля ordering'\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; def __init__(self, user, psw):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._user = user\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._psw = psw\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']</pre>\r\n</div>\r\n</div>\r\n<div>Теперь, при создании объектов:</div>\r\n<div>\r\n<div>\r\n<pre>w = Women('root', '12345')\r\nprint(w.__dict__)</pre>\r\n</div>\r\n</div>\r\n<div>в них дополнительно будут создаваться локальные свойства user и psw:</div>\r\n<div>{'_user': 'root', '_psw': '12345'}</div>\r\n<div><img src=\"http://127.0.0.1:55104/image003.png\"></div>\r\n<div>Но обратите внимание, объект класса Meta при этом не создается. Здесь Meta &ndash; это, по сути, еще один атрибут (пространство имен) в классе Women и мы к нему обращаемся через w как к атрибуту класса, не более того. Если нам нужен объект класса Meta, его нужно явно создать в инициализаторе класса Women:</div>\r\n<div>\r\n<div>\r\n<pre>&nbsp;&nbsp;&nbsp; def __init__(self, user, psw):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._user = user\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._psw = psw\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.meta = self.Meta()</pre>\r\n</div>\r\n</div>\r\n<div>Теперь в экземпляре класса Women имеется ссылка meta на объект класса Meta. Чтобы в этой операции был смысл, давайте пропишем инициализатор во вложенном классе:</div>\r\n<div>\r\n<div>\r\n<pre>class Women:\r\n&nbsp;&nbsp;&nbsp; title = 'объект класса для поля title'\r\n&nbsp;&nbsp;&nbsp; photo = 'объект класса для поля photo'\r\n&nbsp;&nbsp;&nbsp; ordering = 'объект класса для поля ordering'\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; def __init__(self, user, psw):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._user = user\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._psw = psw\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.meta = self.Meta(user + '@' + psw)\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, access):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._access = access</pre>\r\n</div>\r\n</div>\r\n<div>Теперь, при создании объекта класса Women будут автоматически создаваться два объекта: класса Women и класса Meta с соответствующими локальными свойствами:</div>\r\n<div>\r\n<div>\r\n<pre>w = Women('root', '12345')\r\nprint(w.__dict__)\r\nprint(w.meta.__dict__)</pre>\r\n</div>\r\n</div>\r\n<div>И, обратите внимание, мы не можем из класса Meta или из его объектов обращаться к атрибутам класса Women. Это совершенно изолированное пространство имен от внешнего класса. Например, запись вида:</div>\r\n<div>\r\n<div>\r\n<pre>&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = Meta.title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ошибка при обращении к атрибуту title класса Women</pre>\r\n</div>\r\n</div>\r\n<div>приведет к ошибке, так как у вложенного пространства имен класса нет ссылки на внешнее пространство имен класса Women. Мало того, непосредственно во вложенном классе мы даже не можем явно указывать класс Women:</div>\r\n<div>\r\n<div>\r\n<pre>&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = Women.title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ошибка при обращении к атрибуту title класса Women</pre>\r\n</div>\r\n</div>\r\n<div>то тоже приведет к ошибке, так как пространство имен Women на данный момент еще не создано. А вот обращаться к пространству имен Women внутри инициализатора класса Meta можно:</div>\r\n<div>\r\n<div>\r\n<pre>&nbsp;&nbsp;&nbsp; class Meta:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ordering = ['id']\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def __init__(self, access):\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._access = access\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._t = Women.title</pre>\r\n</div>\r\n</div>\r\n<div>Но, обычно, вложенные классы содержат изолированный код, который доступен только из внешнего класса. Именно так следует проектировать программы при использовании вложенных классов.</div>\r\n<div>В заключение занятия отмечу, что подобные вложения служат исключительно для удобства программирования. Какого-то особого, сакрального смысла во вложенных классах нет и все что можно делать через вложения, также можно реализовать и без них, используя обычные, независимые объявления. Но вы вполне можете столкнуться с ними в других проектах, в частности, как я отмечал вначале, во фреймворке Django. И чтобы это не вызывало у удивления, я решил привести пример работы этой конструкции. Надеюсь, вы теперь хорошо себе представляете, как работают вложенные классы.</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>&nbsp;</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>",
      "lesson": 18,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 49,
    "fields": {
      "name": "51. Что такое декоратор?",
      "content": "<p>Декораторы в Python &mdash; это мощный инструмент, который позволяет модифицировать поведение функций или классов без изменения их кода. Они представляют собой функции высшего порядка, то есть функции, которые принимают другие функции в качестве аргументов и возвращают новые функции. В Python декораторы обычно применяются с помощью синтаксиса&nbsp;<code>@decorator</code> перед определением функции или класса.</p>",
      "lesson": 19,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 50,
    "fields": {
      "name": "61. Что такое замыкание функции?",
      "content": "<div><strong>Замыкание (closure) &mdash; это функция, которая запоминает своё лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.</strong></div>\r\n<div>Технически замыкание включает три компонента:</div>\r\n<ol>\r\n<li>Внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры &mdash; лексическое окружение.</li>\r\n<li>Переменные и параметры (лексическое окружение), которые определены во внешней функции.</li>\r\n<li>Вложенная функция, которая использует переменные и параметры внешней функции.</li>\r\n</ol>\r\n<div>Для определения замыканий в Python применяются локальные функции.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Прежде всего позвольте мне на простом примере продемонстрировать, что такое замыкание в Python. Посмотрите на функцию ниже:<br><br>\r\n<pre><code>def outer():<br>    x = 1<br>    def inner():<br>        print(f'x in outer function: {x}')<br>    return inner</code></pre>\r\n<br>Функция&nbsp;<code>outer</code>&nbsp;определяется с функцией&nbsp;<code>inner</code>&nbsp;внутри, а функция&nbsp;<code>outer</code>&nbsp;возвращает функцию&nbsp;<code>inner</code>; именно она &ndash; возвращаемое значение&nbsp;<code>outer</code>.<br><br>Здесь вложенная функция &ndash; это и есть замыкание. Если проверить возвращаемое значение внешней функции, окажется, что оно является функцией.<br><br>\r\n<div><img src=\"http://127.0.0.1:55104/09nk0nx4j1nmgyqoz5lg64b41vk.png\"></div>\r\n<br>Что делает замыкание? Поскольку оно вернуло функцию, мы, конечно, можем запустить её.<br><br>\r\n<div><img src=\"http://127.0.0.1:55104/dipnkm2u_xll2z76ilyyk9jfih0.png\"></div>\r\n<br>Видно, что внутренняя функция может обращаться к переменным, определённым во внешней функции. Обычно замыкание не применяется так, как показано выше, потому что это некрасиво. Мы обычно хотим определить другую функцию, чтобы удерживать функцию, которая возвращается замыканием.<br><br>\r\n<div><img src=\"http://127.0.0.1:55104/td8xbi0bvmr2qquqmpx2up1u08m.png\"></div>\r\n<br>Следовательно, мы также можем сказать, что в замыкании Python мы определили функцию, которая определяет функции.</div>",
      "lesson": 20,
      "ordering_number": 1,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 51,
    "fields": {
      "name": "66. Что такое args и kwargs?",
      "content": "<p>Термины&nbsp;<strong>args</strong>&nbsp;<strong>и</strong>&nbsp;<strong>kwargs</strong>&nbsp;&mdash; это соглашения по программированию на Python, в реальности вместо них можно использовать любые именования.*&nbsp;<strong>args</strong>&nbsp;представляет параметры, которые передаются по позиции. А**&nbsp;<strong>kwargs</strong>&nbsp;означает параметры, которые передаются по имени. обозначает аргументы ключевого слова. Оператор* применяется с любым итерируемым объектом (например, кортежем, списком и строками).<br><br><br></p>\r\n<div>В Python есть возможность передавать переменное количество аргументов в функцию. Это можно сделать с помощью специальных синтаксических конструкций:&nbsp;<code>*args</code>&nbsp;и&nbsp;<code>**kwargs</code>.</div>\r\n<div><code>*args</code>&nbsp;и&nbsp;<code>**kwargs</code>&nbsp;&mdash; это способы передачи переменного количества аргументов в функцию. Слова args и kwargs &mdash; это просто соглашение, их можно заменить на любые другие названия. Важными здесь являются звездочки (<code>*</code>&nbsp;и&nbsp;<code>**</code>), которые указывают на способ передачи аргументов.</div>\r\n<h2>*args</h2>\r\n<blockquote><code>*args</code>&nbsp;используется для передачи неопределенного числа неименованных аргументов. Если поставить звездочку перед именем, это имя будет представлять собой кортеж из всех переданных аргументов функции.</blockquote>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>def</code>&nbsp;<code>function(</code><code>*</code><code>args):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code>&nbsp;<code>i&nbsp;</code><code>in</code>&nbsp;<code>args:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(i)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>function(</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>)</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В приведенном выше примере,&nbsp;<code>args</code>&nbsp;&mdash; это кортеж&nbsp;<code>(1, 2, 3, 4)</code>.</div>\r\n<h2>**kwargs</h2>\r\n<div><code>**kwargs</code>&nbsp;работает так же, как и&nbsp;<code>*args</code>, но вместо кортежа используется словарь. Это позволяет функции принимать любое количество именованных аргументов.</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>def</code>&nbsp;<code>function(</code><code>*</code><code>*</code><code>kwargs):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code>&nbsp;<code>name, value&nbsp;</code><code>in</code>&nbsp;<code>kwargs.items():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'{name} = {value}'</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>function(a</code><code>=</code><code>1</code><code>, b</code><code>=</code><code>2</code><code>, c</code><code>=</code><code>3</code><code>)</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере,&nbsp;<code>kwargs</code>&nbsp;&mdash; это словарь&nbsp;<code>{'a': 1, 'b': 2, 'c': 3}</code>.</div>\r\n<h2>Вариативность параметров</h2>\r\n<div>Способность функции принимать переменное количество аргументов делает ее более универсальной и гибкой. Это может быть полезно, например, когда нужно написать функцию, которая может работать с любым числом элементов.</div>\r\n<div>Например, функция для подсчета суммы любого количества чисел может выглядеть так:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>def</code>&nbsp;<code>sum</code><code>(</code><code>*</code><code>args):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>result&nbsp;</code><code>=</code>&nbsp;<code>0</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code>&nbsp;<code>i&nbsp;</code><code>in</code>&nbsp;<code>args:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>result&nbsp;</code><code>+</code><code>=</code>&nbsp;<code>i</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>result</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<blockquote>Заключение</blockquote>\r\n<div>Умение использовать&nbsp;<code>*args</code>&nbsp;и&nbsp;<code>**kwargs</code> расширяет возможности работы с функциями в Python, делая их более гибкими и универсальными.</div>",
      "lesson": 21,
      "ordering_number": 1,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 52,
    "fields": {
      "name": "67. Для чего нужна конструкция pass?",
      "content": "<div><strong>Конструкция pass в языке программирования Python предназначена для продолжения цикла независимо от наличия внешних условий.</strong></div>\r\n<div>В готовом коде pass встречается нечасто, но полезен в процессе разработки и применяется в качестве &laquo;заглушки&raquo; там, где код еще не написан.</div>",
      "lesson": 21,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 53,
    "fields": {
      "name": "68. Зачем нужно закрывать файлы после работы с ними?",
      "content": "<div><strong>Закрытие файлов после работы с ними в Python важно для освобождения системных ресурсов и предотвращения утечек памяти.</strong></div>\r\n<div>Для работы с файлами в Python используется встроенная функция open(). Она открывает файл и возвращает объект файла, с которым можно работать.</div>\r\n<div>После завершения работы с файлом его необходимо закрыть с помощью метода close().</div>",
      "lesson": 21,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 54,
    "fields": {
      "name": "68.1 Применение механизмов, обеспечивающих своевременное закрытие файлов?",
      "content": "<h3>Применение механизмов, обеспечивающих своевременное закрытие файлов</h3>\r\n<div>Как уже было сказано, в Python существует множество механизмов, предотвращающих ошибки из-за отставленных открытыми файлов и соответственно, обеспечивающих своевременное закрытие тех файлов, которые использовались программой. Все эти механизмы, как правило, обеспечивают автоматическое закрытие файлов при завершении всей программы, либо каких-то ее процессов за счет использования вышеописанных файловых дескрипторов. Так, например, при выполнении этого кода:</div>\r\n<div>\r\n<pre><code># write_hello.py\r\nfile = open(\"hello.txt\", mode=\"w\")\r\nfile.write(\"Hello, world!\")\r\n</code></pre>\r\n</div>\r\n<div>Python после создания файла&nbsp;<em>hello.txt</em>&nbsp;и записи в него текста&nbsp;<em>'Hello, world!'</em>&nbsp;сам заботиться о том, чтобы этот файл был автоматически закрыт после благополучного завершения программы.</div>\r\n<div>Однако, что, если данная программа не завершится корректно, например, из-за отключения электричества в момент ее выполнения? Смоделируем эту ситуацию программным путем за счет применения функции&nbsp;<strong>os._exit(1)</strong>, имитирующей сбой программы:</div>\r\n<div>\r\n<pre><code># crash_hello.py\r\nimport os\r\nfile = open(\"crash.txt\", mode=\"w\")\r\nfile.write(\"Hello, world!\")\r\nos._exit(1)\r\n</code></pre>\r\n</div>\r\n<div>Результат выполнения последнего фрагмента кода можно посмотреть путем вывода содержимого файла '&nbsp;<em>crash.txt'</em>, используя команду&nbsp;<strong>cat</strong>&nbsp;(для UNIX-систем):</div>\r\n<div>\r\n<pre><code>$ cat crash.txt\r\n$ # No output!\r\n</code></pre>\r\n</div>\r\n<div>Как видим, что хотя вышеназванный файл и был создан ОС, но он оказался пустым.&nbsp;Таким образом, при написании программ лучше все же закрывать файлы сразу после того, как они были использованы. Это можно сделать путем использования конструкции&nbsp;<strong>try... finally</strong>:</div>\r\n<div>\r\n<pre><code>try:\r\n    file = open(\"hello.txt\", mode=\"w\")\r\n    file.write(\"Hello, World!\")\r\nfinally:\r\n    file.close()\r\n</code></pre>\r\n</div>\r\n<div>Где блок&nbsp;<strong>finally</strong>&nbsp;безальтернативно закрывает файл&nbsp;<em>'hello.txt'</em>&nbsp;независимо от того, успешно ли был выполнен блок&nbsp;<strong>try</strong>. Вмести с тем, использования конструкции&nbsp;<strong>try... finally</strong>&nbsp;для своевременного закрытия файлов является довольно громоздким и трудночитаемым. Гораздо более компактный и интуитивно понятный подход в Python обеспечивается применением так называемого&nbsp;<strong>контекстного менеджера</strong>, благодаря которому вышеприведенный код выглядит следующим образом:</div>\r\n<div>\r\n<pre><code>with open(\"hello.txt\", mode=\"w\") as file:\r\n    file.write(\"Hello, World!\")\r\n</code></pre>\r\n</div>\r\n<div>Первой строкой в этом коде (оператором&nbsp;<strong>with</strong>) инициируется контекстный менеджер - блок, все последующие строки которого являются строками с отступом. Как только эти строки с отступом заканчиваются или же при их выполнении вызывается какое-либо исключение, файлы, обрабатываемые в данном контекстном менеджере, закрываются. Таким образом программы, написанные с использованием подобных менеджеров компактны, интуитивно понятны и читабельны.</div>",
      "lesson": 21,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 55,
    "fields": {
      "name": "69. Для чего служит функция zip?",
      "content": "<p><strong>Функция</strong>&nbsp;<strong>zip</strong>&nbsp;() в&nbsp;<strong>Python</strong>&nbsp;используется для одновременной итерации по нескольким итерируемым объектам (например, спискам, кортежам, строкам) параллельно. Она создает итератор, который генерирует кортежи, состоящие из соответствующих элементов из каждого итерируемого объекта. Важные моменты: Длина итератора: Итератор, созданный&nbsp;<strong>zip</strong>&nbsp;(), будет иметь длину, равную длине самого короткого итерируемого объекта, переданного в&nbsp;<strong>функцию</strong>.<br><br></p>\r\n<div>Часто при работе с данными на Python возникает ситуация, когда необходимо преобразовать список кортежей в два отдельных списка, где первый список содержит первые элементы всех кортежей, а второй &mdash; вторые элементы.</div>\r\n<div>Приведем пример. Допустим, есть список кортежей, каждый из которых содержит букву и соответствующее ей число:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>data&nbsp;</code><code>=</code>&nbsp;<code>[(</code><code>'a'</code><code>,&nbsp;</code><code>1</code><code>), (</code><code>'b'</code><code>,&nbsp;</code><code>2</code><code>), (</code><code>'c'</code><code>,&nbsp;</code><code>3</code><code>), (</code><code>'d'</code><code>,&nbsp;</code><code>4</code><code>)]</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Нужно преобразовать этот список в следующий формат:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>result&nbsp;</code><code>=</code>&nbsp;<code>([</code><code>'a'</code><code>,&nbsp;</code><code>'b'</code><code>,&nbsp;</code><code>'c'</code><code>,&nbsp;</code><code>'d'</code><code>], [</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>])</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В Python есть встроенная функция zip(), которая позволяет решить эту задачу.</div>\r\n<div>Функция zip() используется для совмещения двух и более списков в один. Она возвращает итератор кортежей, где i-ый кортеж содержит i-ый элемент из каждого из переданных списков.</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>x&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>]</code></div>\r\n<div><code>y&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>4</code><code>,&nbsp;</code><code>5</code><code>,&nbsp;</code><code>6</code><code>]</code></div>\r\n<div><code>zipped&nbsp;</code><code>=</code>&nbsp;<code>zip</code><code>(x, y)</code></div>\r\n<div><code>print</code><code>(</code><code>list</code><code>(zipped))</code></div>\r\n<div><code># Выведет: [(1, 4), (2, 5), (3, 6)]</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Также функция zip() может быть использована для &laquo;расстегивания&raquo; списка кортежей обратно в отдельные списки. Для этого используется оператор &laquo;*&raquo;. Он позволяет преобразовать список в набор аргументов для функции.</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>zipped&nbsp;</code><code>=</code>&nbsp;<code>[(</code><code>1</code><code>,&nbsp;</code><code>4</code><code>), (</code><code>2</code><code>,&nbsp;</code><code>5</code><code>), (</code><code>3</code><code>,&nbsp;</code><code>6</code><code>)]</code></div>\r\n<div><code>x, y&nbsp;</code><code>=</code>&nbsp;<code>zip</code><code>(</code><code>*</code><code>zipped)</code></div>\r\n<div><code>print</code><code>(</code><code>list</code><code>(x))</code></div>\r\n<div><code># Выведет: [1, 2, 3]</code></div>\r\n<div><code>print</code><code>(</code><code>list</code><code>(y))</code></div>\r\n<div><code># Выведет: [4, 5, 6]</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Таким образом, для преобразования списка кортежей в два списка можно использовать следующий код:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>data&nbsp;</code><code>=</code>&nbsp;<code>[(</code><code>'a'</code><code>,&nbsp;</code><code>1</code><code>), (</code><code>'b'</code><code>,&nbsp;</code><code>2</code><code>), (</code><code>'c'</code><code>,&nbsp;</code><code>3</code><code>), (</code><code>'d'</code><code>,&nbsp;</code><code>4</code><code>)]</code></div>\r\n<div><code>x, y&nbsp;</code><code>=</code>&nbsp;<code>zip</code><code>(</code><code>*</code><code>data)</code></div>\r\n<div><code>result&nbsp;</code><code>=</code>&nbsp;<code>(</code><code>list</code><code>(x),&nbsp;</code><code>list</code><code>(y))</code></div>\r\n<div><code>print</code><code>(result)</code></div>\r\n<div><code># Выведет: (['a', 'b', 'c', 'd'], [1, 2, 3, 4])</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом коде функция zip() с оператором &laquo;*&raquo; преобразует список кортежей в два отдельных кортежа. Затем каждый из этих кортежей преобразуется в список с помощью функции list().</div>",
      "lesson": 21,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 56,
    "fields": {
      "name": "70. Что такое переменная self",
      "content": "<div><strong>Переменная self в Python</strong>&nbsp;представляет собой экземпляр или объекты класса и связывает атрибуты класса с определёнными аргументами.</div>\r\n<div>Использование переменной self в Python позволяет разграничить атрибуты (и методы) экземпляра и локальные переменные.</div>\r\n<div>Переменная self работает как ссылка на объект и используется для обращения к атрибутам и методам экземпляра класса.</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Один из основных элементов объектно-ориентированного программирования в Python &mdash; это использование классов и методов. Во время работы с методами класса сталкиваются с таким понятием, как&nbsp;<code>self</code>. Это слово встречается в параметрах метода, и иногда может вызывать замешательство.</div>\r\n<div>Рассмотрим пример кода:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>class</code>&nbsp;<code>SampleClass:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>sample_method(</code><code>self</code><code>, value):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>self</code><code>.value&nbsp;</code><code>=</code>&nbsp;<code>value</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В данном случае,&nbsp;<code>self</code>&nbsp;является ссылкой на текущий экземпляр класса&nbsp;<code>SampleClass</code>. Это позволяет доступ к его атрибутам и методам внутри класса.</div>\r\n<div>Зачастую вопрос состоит в том, почему&nbsp;<code>self</code>&nbsp;является явным параметром, а не неявным, как в некоторых других языках программирования. В Python,&nbsp;<code>self</code>&nbsp;является явным параметром для того, чтобы подчеркнуть, что метод применяется к конкретному экземпляру класса. Это делает код более ясным и понятным.</div>\r\n<div>То есть, когда вызывается метод, например&nbsp;<code>sample_method</code>, интерпретатор Python автоматически передает ссылку на текущий объект (<code>self</code>) в качестве первого аргумента. Вот почему, при вызове метода не нужно явно передавать&nbsp;<code>self</code>.</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>obj&nbsp;</code><code>=</code>&nbsp;<code>SampleClass()</code></div>\r\n<div><code>obj.sample_method(</code><code>10</code><code>)&nbsp;&nbsp;</code><code># Здесь self не передается явно</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Использование&nbsp;<code>self</code> является стандартной практикой и соглашением между программистами. Оно обеспечивает ясность кода, показывая, что метод применяется к экземпляру класса.</div>\r\n</div>",
      "lesson": 21,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 57,
    "fields": {
      "name": "62. Для чего используется класс Meta в Django?",
      "content": "<div>Класс Meta в Django используется для&nbsp;<strong>определения различных параметров модели</strong>:&nbsp;</div>\r\n<ul>\r\n<li>разрешений;&nbsp;</li>\r\n<li>имени базы данных;&nbsp;</li>\r\n<li>единственного и множественного имён;&nbsp;</li>\r\n<li>абстракции;&nbsp;</li>\r\n<li>порядка и т. д..&nbsp;</li>\r\n</ul>\r\n<div>Добавление класса Meta в модели Django&nbsp;<strong>необязательно</strong>. Он представляет собой внутренний класс, который определяется внутри модели.&nbsp;</div>",
      "lesson": 20,
      "ordering_number": 2,
      "steps_used_users": [
        1
      ]
    }
  },
  {
    "model": "content_app.step",
    "pk": 58,
    "fields": {
      "name": "62.1 Для чего используется класс Meta в Django?",
      "content": "<div><strong>Метамодель (Meta Model)</strong>&nbsp;- это, по сути, внутренний класс вашего класса модели. Метамодель в основном используется для изменения поведения полей вашей модели, таких как изменение опций заказа, verbose_name, и многих других параметров. Добавление класса Meta к вашей модели совершенно необязательно. Для того чтобы использовать метамодель, вы должны добавить класс Meta в вашу модель, как показано ниже:&nbsp;</div>\r\n<pre><code>class student(models.Model):<br>    class Meta:<br>        options........</code></pre>\r\n<h3>Опции метамодели</h3>\r\n<div>Метамодель имеет множество опций, которые вы можете предоставить вашей модели в ее внутреннем классе meta</div>\r\n<p>1. abstract</p>\r\n<div>Если abstract = True, то данная модель будет абстрактным базовым классом:</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tabstract = True<br></code></pre>\r\n<p>2. app_label</p>\r\n<div>Если модель определена за пределами приложений в&nbsp;<code>INSTALLED_APPS</code>, то ей необходимо объявить, какому приложению она принадлежит:</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tapp_label = 'myapp' # add app name here<br></code></pre>\r\n<p>3. verbose_name</p>\r\n<div><code>verbose_name</code>&nbsp;- это по сути понятное человеку имя для вашей модели.</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tverbose_name = \"stu\" # add verbose_name here<br></code></pre>\r\n<p>4. ordering&nbsp;</p>\r\n<div>Ordering (упорядочивание) в основном используется для изменения порядка полей вашей модели.</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tordering = [-1]<br></code></pre>\r\n<div>Добавьте упорядочивание вот так [-1], и порядок изменится на убывающий.</div>\r\n<div><strong>5. proxy</strong></div>\r\n<div>Если мы добавим proxy = True, модель, которая является подклассом другой модели, будет рассматриваться как прокси-модель.</div>\r\n<pre><code>class Teacher(models.Model):<br>pass<br><br>class Student(Teacher):<br>class Meta:<br>\tproxy = True</code></pre>\r\n<div>Вот как мы можем создать прокси-модель.</div>\r\n<p>6. permissions&nbsp;</p>\r\n<div>Дополнительные permissions (разрешения), которые нужно внести в таблицу разрешений при создании этого объекта. Разрешения на добавление, изменение, удаление и просмотр автоматически создаются для каждой модели.</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tpermissions = []<br>\t</code></pre>\r\n<div>Вы можете добавить дополнительные разрешения внутри списка.</div>\r\n<p>7. db_table</p>\r\n<div>Мы можем перезаписать имя таблицы, используя db_table в классе meta.</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tdb_table = 'X'</code></pre>\r\n<div>Это изменит имя таблицы на X.</div>\r\n<p>8. get_latest_by</p>\r\n<div>Возвращает последний объект в таблице на основе заданного поля, обычно используемого для DateField, DateTimeField или IntegerField.</div>\r\n<pre><code>class student(models.Model):<br>class Meta:<br>\tget_latest_by = \"order_date\"</code></pre>\r\n<div>Возвращает последний по порядку возрастания&nbsp;<code>order_date</code>.</div>",
      "lesson": 20,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 59,
    "fields": {
      "name": "63. Что такое курсор?",
      "content": "<p>Курсор &ndash; это объект доступа к данным, который может использоваться как для итерации набора строк в таблице, так и для вставки новых строк в таблицу. Курсоры могут быть трех форм: поиска, вставки или обновления. Как правило, курсоры используются для&nbsp;<a href=\"https://desktop.arcgis.com/ru/arcmap/10.3/analyze/python/reading-geometries.htm\">считывания существующей геометрии</a>&nbsp;и&nbsp;<a href=\"https://desktop.arcgis.com/ru/arcmap/10.3/analyze/python/writing-geometries.htm\">записи новых геометрий</a>.</p>",
      "lesson": 20,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 60,
    "fields": {
      "name": "64. Назови основные свойства транзакций",
      "content": "<div>Основные свойства транзакций:</div>\r\n<ul>\r\n<li><strong>Атомарность</strong>. Многие операции с базой данных выполняются как единый этап работы. В случае сбоя какой-либо из операций происходит откат всей транзакции, отменяя все изменения.&nbsp;</li>\r\n<li><strong>Согласованность</strong>. База данных должна начинаться в согласованном состоянии и должна возвращаться в это состояние после фиксации транзакции.&nbsp;</li>\r\n<li><strong>Изоляция</strong>. Операции одной транзакции не будут видны операциям других транзакций до тех пор, пока транзакция не будет зафиксирована. Это обеспечивает изоляцию между параллельными транзакциями.&nbsp;</li>\r\n<li><strong>Долговечность</strong>. После фиксации транзакции внесённые в неё изменения являются необратимыми и не могут быть отменены даже в случае системного сбоя.&nbsp;</li>\r\n</ul>",
      "lesson": 20,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 61,
    "fields": {
      "name": "65. Чем отличаются HTTP и HTTPS?",
      "content": "<p>HTTPS и HTTP отличаются протоколом шифрования при передаче данных. HTTP (HyperText Transfer Protocol) &ndash; устаревший незащищенный протокол. HTTPS &ndash; защищенный протокол передачи данных с криптографическим шифрованием HyperText Transfer Protocol Secure. Для перехода на защищенное соединение к сайту подключается SSL-сертификат, а потом настроить переадресацию с HTTP на HTTPS с помощью файла .htaccess.</p>",
      "lesson": 20,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 62,
    "fields": {
      "name": "51.2 Как создать декоратор?",
      "content": "<div>Создание декоратора в Python происходит в несколько этапов. Рассмотрим пример создания простого декоратора, который выводит информацию о вызове функции:</div>\r\n<ol>\r\n<li>Определите функцию-декоратор, которая принимает в качестве аргумента другую функцию:</li>\r\n</ol>\r\n<div>\r\n<div>\r\n<table style=\"width: 20.6025%;\">\r\n<tbody>\r\n<tr>\r\n<td style=\"width: 54.7662%;\">\r\n<div>1</div>\r\n<div>2</div>\r\n</td>\r\n<td style=\"width: 45.2338%;\">\r\n<div>\r\n<div><code>def</code>&nbsp;<code>my_decorator(func):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;</code><code>...</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<ol>\r\n<li>Внутри функции-декоратора определите новую функцию (обычно называемую &laquo;wrapper&raquo; или &laquo;обертка&raquo;), которая будет выполнять дополнительные действия перед и/или после вызова исходной функции:</li>\r\n</ol>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>def</code>&nbsp;<code>my_decorator(func):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>wrapper():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Что-то происходит перед вызовом функции\"</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>func()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Что-то происходит после вызова функции\"</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>wrapper</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<ol>\r\n<li>Верните из функции-декоратора новую функцию-обертку:</li>\r\n</ol>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>def</code>&nbsp;<code>my_decorator(func):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>wrapper():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>...</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>wrapper</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<ol>\r\n<li>Теперь можно применить созданный декоратор к любой функции с помощью синтаксиса&nbsp;<code>@decorator</code>:</li>\r\n</ol>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>@my_decorator</code></div>\r\n<div><code>def</code>&nbsp;<code>say_hello():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Привет, мир!\"</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>say_hello()</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В результате выполнения кода мы увидим следующий вывод:</div>\r\n<pre><code>Что-то происходит перед вызовом функции\r\nПривет, мир!\r\nЧто-то происходит после вызова функции</code></pre>",
      "lesson": 19,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 63,
    "fields": {
      "name": "51.3 Пример использования декоратора",
      "content": "<h2>Пример использования декоратора</h2>\r\n<div>Рассмотрим пример использования декоратора для измерения времени выполнения функции:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n<div>9</div>\r\n<div>10</div>\r\n<div>11</div>\r\n<div>12</div>\r\n<div>13</div>\r\n<div>14</div>\r\n<div>15</div>\r\n<div>16</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>import</code>&nbsp;<code>time</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>def</code>&nbsp;<code>timing_decorator(func):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>wrapper():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>start_time&nbsp;</code><code>=</code>&nbsp;<code>time.time()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>func()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>end_time&nbsp;</code><code>=</code>&nbsp;<code>time.time()</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>\"Функция {func.__name__} выполнялась {end_time - start_time:.2f} секунд\"</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>wrapper</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>@timing_decorator</code></div>\r\n<div><code>def</code>&nbsp;<code>some_long_running_function():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>time.sleep(</code><code>2</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Функция завершила работу\"</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>some_long_running_function()</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В данном примере декоратор&nbsp;<code>timing_decorator</code>&nbsp;измеряет время выполнения функции&nbsp;<code>some_long_running_function</code> и выводит результат на экран.</div>",
      "lesson": 19,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 64,
    "fields": {
      "name": "51.4 Как связаны декораторы и замыкания",
      "content": "<h2>Как связаны декораторы и замыкания</h2>\r\n<div>Внутренняя функция&nbsp;<code>wrapper</code>&nbsp;декоратора обычно ссылается на переменные из внешней функции, что создает замыкание. В примере с декоратором&nbsp;<code>debug_decorator</code>&nbsp;функция&nbsp;<code>wrapper</code>&nbsp;ссылается на&nbsp;<code>func</code>, которая была определена во внешней функции&nbsp;<code>debug_decorator</code>. Это позволяет декоратору использовать и изменять переменные из внешней функции в рамках своей логики работы, что делает декораторы более гибкими инструментами.</div>\r\n<div>Также декораторы могут использовать замыкания, чтобы сохранять состояния между вызовами функции. Например, декоратор может создать замыкание, которое сохраняет информацию о том, сколько раз функция была вызвана, и возвращать это значение при каждом вызове функции.</div>\r\n<div>Вот пример декоратора, который использует замыкание, чтобы отслеживать количество вызовов функции:</div>\r\n<pre><code>def count_calls(func):\r\n    num_calls = 0\r\n    def wrapper(*args, **kwargs):\r\n        nonlocal num_calls\r\n        num_calls += 1\r\n        print(f\"Функция была вызвана {num_calls} раз(а)\")\r\n        return func(*args, **kwargs)\r\n    return wrapper\r\n\r\n@count_calls\r\ndef my_func():\r\n    print(\"Hello, world!\")\r\n\r\nmy_func()\r\n# Функция была вызвана 1 раз(а)\r\n# Hello, world!\r\nmy_func()\r\n# Функция была вызвана 2 раз(а)\r\n# Hello, world!\r\n</code></pre>\r\n<div>В этом примере декоратор&nbsp;<code>count_calls</code>&nbsp;принимает функцию&nbsp;<code>func</code>&nbsp;и возвращает новую функцию&nbsp;<code>wrapper</code>. Последняя отслеживает количество вызовов&nbsp;<code>func</code>&nbsp;и выводит сообщение при каждом вызове. Затем декоратор применяется к функции&nbsp;<code>my_func</code>. Каждый раз, когда&nbsp;<code>my_func</code>&nbsp;вызывается, декоратор увеличивает счетчик вызовов и выводит сообщение.</div>\r\n<div>Рассмотрим еще один пример, где создадим декоратор, который измеряет время выполнения функции:</div>\r\n<pre><code>import time\r\n\r\ndef timer(func):\r\n    def wrapper(*args, **kwargs):\r\n        start_time = time.time()\r\n        result = func(*args, **kwargs)\r\n        end_time = time.time()\r\n        print(f\"Время выполнения функции {func.__name__}: {end_time - start_time} сек.\")\r\n        return result\r\n    return wrapper\r\n\r\n@timer\r\ndef some_function():\r\n    time.sleep(2)\r\n\r\nsome_function()\r\n# Время выполнения функции some_function: 2.000108242034912 сек.\r\n</code></pre>\r\n<div>Здесь мы определяем декоратор&nbsp;<code>timer</code>, который принимает функцию&nbsp;<code>func</code>&nbsp;и возвращает функцию-обертку&nbsp;<code>wrapper</code>. Функция-обертка вызывает функцию&nbsp;<code>func</code>, замеряет время ее выполнения и сохраняет результат работы&nbsp;<code>func</code>&nbsp;в переменную&nbsp;<code>result</code>. Затем функция-обертка выводит время выполнения функции на экран и возвращает результат вызова функции.</div>\r\n<div>В конце применяем декоратор&nbsp;<code>timer</code>&nbsp;к функции&nbsp;<code>some_function</code>. Когда мы вызываем функцию&nbsp;<code>some_function</code>, декоратор автоматически вызывается и выводит время выполнения функции на экран.</div>",
      "lesson": 19,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 65,
    "fields": {
      "name": "52. Для чего используется Git?",
      "content": null,
      "lesson": 19,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 66,
    "fields": {
      "name": "52.1 Основные понятия Git",
      "content": "<h2>Основные понятия Git</h2>\r\n<ul>\r\n<li><strong>Репозиторий</strong>: это хранилище, содержащее все файлы и историю изменений проекта.</li>\r\n<li><strong>Коммит</strong>: фиксация изменений в репозитории с описанием внесенных изменений.</li>\r\n<li><strong>Ветка (branch)</strong>: отдельный поток разработки, который позволяет создавать и тестировать новые функции, не затрагивая основной код.</li>\r\n<li><strong>Слияние (merge)</strong>: объединение изменений из одной ветки в другую.</li>\r\n</ul>",
      "lesson": 19,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 67,
    "fields": {
      "name": "52.2 Настройка Git",
      "content": "<h2>Настройка Git</h2>\r\n<div>После установки, укажите ваше имя и адрес электронной почты, чтобы другие разработчики могли идентифицировать вас как автора изменений:</div>\r\n<pre><code>git config --global user.name \"Your Name\"\r\ngit config --global user.email \"your.email@example.com\"</code></pre>",
      "lesson": 19,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 68,
    "fields": {
      "name": "52.3 Создание репозитория",
      "content": "<h2>Создание репозитория</h2>\r\n<div>Для создания нового репозитория, выполните следующие команды в командной строке:</div>\r\n<pre><code>mkdir new_project\r\ncd new_project\r\ngit init\r\n</code></pre>\r\n<div>Это создаст новую папку&nbsp;<code>new_project</code> и инициализирует в ней пустой Git-репозиторий.</div>",
      "lesson": 19,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 69,
    "fields": {
      "name": "52.4 Работа с репозиторием",
      "content": "<h3>Добавление файлов</h3>\r\n<div>Чтобы добавить файлы в репозиторий, выполните команду&nbsp;<code>git add</code>:</div>\r\n<pre><code>git add file1.txt\r\ngit add file2.txt\r\n</code></pre>\r\n<h3>Создание коммита</h3>\r\n<div>После добавления файлов, создайте коммит с описанием внесенных изменений:</div>\r\n<pre><code>git commit -m \"Add file1 and file2\"\r\n</code></pre>\r\n<h3>Просмотр истории коммитов</h3>\r\n<div>Для просмотра истории коммитов в репозитории, используйте команду&nbsp;<code>git log</code>:</div>\r\n<pre><code>git log\r\n</code></pre>\r\n<h3>Создание веток</h3>\r\n<div>Для создания новой ветки, выполните команду&nbsp;<code>git checkout</code>&nbsp;с флагом&nbsp;<code>-b</code>:</div>\r\n<pre><code>git checkout -b new_feature\r\n</code></pre>\r\n<h3>Слияние веток</h3>\r\n<div>Для слияния изменений из одной ветки в другую, сначала переключитесь на ветку, в которую хотите объединить изменения, а затем выполните команду&nbsp;<code>git merge</code>:</div>\r\n<pre><code>git checkout master\r\ngit merge new_feature</code></pre>",
      "lesson": 19,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 70,
    "fields": {
      "name": "53. Что такое SOLID? Расскажи подробнее про каждый пункт",
      "content": "<div><strong>Аббревиатура SOLID включает в себя пять основных принципов объектно-ориентированного программирования:</strong></div>\r\n<ol>\r\n<li>Принцип единственной ответственности (Single Responsibility Principle &mdash; SRP).</li>\r\n<li>Принцип открытости/закрытости (Open/Closed Principle &mdash; OCP).</li>\r\n<li>Принцип подстановки Лисков (Liskov Substitution Principle &mdash; LSP).</li>\r\n<li>Принцип разделения интерфейса (Interface Segregation Principle &mdash; ISP).</li>\r\n<li>Принцип инверсии зависимостей (Dependency Inversion Principle &mdash; DIP).</li>\r\n</ol>",
      "lesson": 19,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 71,
    "fields": {
      "name": "53.1 Принцип единственной ответственности (Single Responsibility Principle — SRP).",
      "content": "<div><strong>Принцип единой ответственности (SRP)</strong>&nbsp;в Python гласит, что&nbsp;<strong>каждый класс, метод и функция должны выполнять только одну задачу или иметь только одну причину для изменения</strong>.</div>\r\n<div>Цели применения принципа:</div>\r\n<div>&mdash; создавать классы, методы и функции с высокой степенью взаимозависимости между подмодулями;<br>&mdash; способствовать композиции классов;<br>&mdash; избегать дублирования кода.</div>",
      "lesson": 19,
      "ordering_number": 11,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 72,
    "fields": {
      "name": "53.2 Принцип открытости/закрытости (Open/Closed Principle — OCP).",
      "content": "<div><strong>Принцип открытости/закрытости (Open‐Closed Principle)</strong>&nbsp;гласит, что сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений.</div>\r\n<div>Следование этому принципу гарантирует, что класс определён достаточно, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путём создания новых сущностей, которые расширяют возможности существующего класса и добавляют дополнительные функции самим себе.</div>\r\n<div>Этот принцип был впервые сформулирован Бернардом Мейером в 1988 году.</div>",
      "lesson": 19,
      "ordering_number": 12,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 73,
    "fields": {
      "name": "53.3 Принцип подстановки Лисков (Liskov Substitution Principle — LSP).",
      "content": "<div><strong>Принцип подстановки Лисков (Liskov Substitution Principle, LSP) в Python</strong>&nbsp;гласит, что&nbsp;<strong>объекты в программе должны быть заменяемыми экземплярами их базовых типов, не нарушая корректность программы</strong>.&nbsp;</div>\r\n<div>Это означает, что&nbsp;<strong>код, который работает с базовым типом, должен работать и с любым его подтипом</strong>, не вызывая ошибок или неожиданного поведения. Этот принцип обеспечивает согласованность в использовании наследования и полиморфизма.&nbsp;</div>\r\n<div><strong>Простыми словами</strong> &mdash; классы-наследники не должны противоречить базовому классу. Например, они не могут предоставлять интерфейс уже базового. Поведение наследников должно быть ожидаемым для функций, которые используют базовый класс.&nbsp;</div>",
      "lesson": 19,
      "ordering_number": 13,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 74,
    "fields": {
      "name": "53.4 Принцип разделения интерфейса (Interface Segregation Principle — ISP).",
      "content": "<div><strong>Принцип разделения интерфейсов (ISP)</strong>&nbsp;&mdash; это один из принципов SOLID, который гласит, что&nbsp;<strong>клиентов не следует заставлять зависеть от методов, которые они не используют</strong>.</div>\r\n<div>Интерфейсы принадлежат клиентам, а не иерархиям. В этом случае клиенты &mdash; это классы и подклассы, а интерфейсы состоят из методов и атрибутов.</div>\r\n<div>Другими словами, если класс не использует определённые методы или атрибуты, то эти методы и атрибуты должны быть разделены на более конкретные классы.</div>",
      "lesson": 19,
      "ordering_number": 14,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 75,
    "fields": {
      "name": "53.5 Принцип инверсии зависимостей (Dependency Inversion Principle — DIP).",
      "content": "<div>Этот принцип SOLID в Java описывают так:&nbsp;<strong>зависимости внутри СИСТЕМЫ строятся на основе абстракций</strong>.&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Модули верхнего уровня не зависят от модулей нижнего уровня.</div>\r\n<div>&nbsp;Абстракции не должны зависеть от деталей.</div>\r\n<div>Детали должны зависеть от абстракций.&nbsp;</div>\r\n<div>&nbsp;Программное обеспечение нужно разрабатывать так, чтобы различные МОДУЛИ были автономными и соединялись друг с другом с помощью абстракции.</div>",
      "lesson": 19,
      "ordering_number": 15,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 76,
    "fields": {
      "name": "54. Для чего служат staticmethod и classmethod? Чем они отличаются?",
      "content": "<div><strong>Статические методы, как и методы класса, &mdash; это методы, привязанные к классу, а не к его объекту. Они не требуют создания экземпляра класса. Они не зависят от состояния объекта.</strong></div>\r\n<div>Разница между статическим методом и методом класса:</div>\r\n<div>Статический метод ничего не знает о классе и имеет дело только с параметрами.</div>\r\n<div>Метод класса работает с классом, поскольку его параметром всегда является сам класс.</div>\r\n<div>Их может вызывать как класс, так и его объект.</div>\r\n<div>&nbsp;</div>",
      "lesson": 19,
      "ordering_number": 16,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 77,
    "fields": {
      "name": "55. Что такое область видимости переменных? Какие области видимости переменных ты знаешь?",
      "content": "<div>Python использует четыре области видимости:</div>\r\n<div>\r\n<ol>\r\n<li>L (Local) &mdash; внутри функции или класса, где была объявлена переменная.</li>\r\n<li>E (Enclosing) &mdash; внутри внешних функций, от ближайшего к дальнему.</li>\r\n<li>G (Global) &mdash; на уровне модуля или скрипта.</li>\r\n<li>B (Built-in) &mdash; встроенные функции и исключения Python.</li>\r\n</ol>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>Это правило называется LEGB и описывает порядок, в котором Python ищет переменные.</div>",
      "lesson": 19,
      "ordering_number": 17,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 78,
    "fields": {
      "name": "56. Что такое Middleware в Django",
      "content": "<p>1. Что такое Middleware?</p>\r\n<div>С точки зрения пользователя&nbsp; &mdash; &nbsp;<em>Middleware&nbsp;</em>(<em>программное обеспечение промежуточного слоя, связующее, межплатформенное ПО</em>)  &mdash;  это словно мост, связывающий между собой две части программы или системы.</div>\r\n<div>В технических терминах&nbsp;&nbsp; &mdash; &nbsp;<em>Django Middleware</em><strong><em>&nbsp;</em> &mdash;  это промежуточный слой между запросом и ответом</strong>, это легкая, низкоуровневая&nbsp;<strong>система &ldquo;плагинов&rdquo;</strong>&nbsp;для глобального изменения входных или выходных данных. Каждый компонент промежуточного слоя отвечает за выполнение определенной функции.</div>\r\n<div>&nbsp;</div>",
      "lesson": 19,
      "ordering_number": 18,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 79,
    "fields": {
      "name": "56.1 Как работает Django Middleware?",
      "content": "<p><em>Как работает Django Middleware?</em><img src=\"https://cdn-images-1.medium.com/max/1000/1*WgX3kRvplONVtvgDNh9iSg.png\" alt=\"\"><br><br>Схема работы Django Middleware</p>\r\n<div>Когда пользователь инициирует запрос из вашего приложения, создается&nbsp;<strong>обработчик WSGI, выполняющий следующие действия по порядку</strong>:</div>\r\n<ul>\r\n<li>Импорт модуля&nbsp;<code>settings.py</code>&nbsp;из корневой директории проекта.</li>\r\n<li>Импорт классов исключений&nbsp;<em>Django</em>.</li>\r\n<li>Загрузка всех классов связующего ПО, указанных в кортеже&nbsp;<code>MIDDLEWARE</code>&nbsp;из модуля&nbsp;<code>settings.py</code>.</li>\r\n<li>Построение списка методов для обработки представлений, исключений, запросов и ответов.</li>\r\n<li>Перебор методов запроса&nbsp;<em>(request)</em>&nbsp;по порядку.</li>\r\n<li>Выдача прав доступа к запрошенному ресурсу по&nbsp;<em>URL</em>.</li>\r\n<li>Обход каждого из методов обработки представлений&nbsp;<em>(views)</em>&nbsp;по порядку.</li>\r\n<li>Вызов функции представления или метода&nbsp;<code>dispatch()</code>&nbsp;для представления-класса.</li>\r\n<li>Обработка методов выброса исключений, если такие есть.</li>\r\n<li>Обход каждого из методов ответа&nbsp;<em>(response)</em>&nbsp;в обратном порядке от обхода методов запроса.</li>\r\n<li>Построение возвращаемого значения и выполнение функции обратного вызова&nbsp;<em>(callback)</em>.</li>\r\n</ul>",
      "lesson": 19,
      "ordering_number": 19,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 80,
    "fields": {
      "name": "56.2  Пользовательский Django Middleware",
      "content": "<p>Пользовательский Django Middleware<br><br></p>\r\n<div><em>Django</em>&nbsp;предоставляет два типа связующего<em>&nbsp;</em>программного обеспечения:</div>\r\n<ol>\r\n<li>Стандартные (встроенные)&nbsp;<em>Middleware</em>.</li>\r\n<li>Пользовательские&nbsp;<em>Middleware</em>.</li>\r\n</ol>\r\n<div>Стандартное связующее ПО предоставляется по умолчанию, когда вы создаете свой новый Django-проект; проверить список&nbsp;<em>Middleware</em>&nbsp;по умолчанию можно в модуле&nbsp;<code>settings.py</code>&nbsp;из корневой директории проекта:</div>\r\n<pre><code>MIDDLEWARE = [\r\n    'django.middleware.security.SecurityMiddleware',\r\n    'django.contrib.sessions.middleware.SessionMiddleware',\r\n    'django.middleware.common.CommonMiddleware',\r\n    'django.middleware.csrf.CsrfViewMiddleware',\r\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n    'django.contrib.messages.middleware.MessageMiddleware',\r\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r\n]</code></pre>\r\n<div>Встроенное промежуточное ПО Django по умолчанию</div>\r\n<div><strong>Пользовательское связующее ПО  </strong>&mdash;  это ваши собственные&nbsp;<em>Middleware</em>&nbsp;для использования во всем проекте.&nbsp;<em>Давайте рассмотрим, как их писать:</em></div>\r\n<ul>\r\n<li>Создайте Python-пакет (папку с файлом __init__.py внутри) под названием&nbsp;<code>middleware</code>.</li>\r\n<li>В директории пакета создайте модуль под названием&nbsp;<code>custom_middleware.py</code>, определите обычную функцию либо класс.</li>\r\n<li>Теперь всё готово для создания ПО промежуточного слоя в форме функции или класса с вызываемыми экземплярами.</li>\r\n</ul>\r\n<div><strong>Пользовательский Django Middleware на основе функции:</strong></div>\r\n<pre><code>def simple_middleware(get_response):\r\n    # Инициализация и настройка\r\n    def middleware(request):\r\n        # Код, вызываемый перед представлением при каждом запросе.\r\n        response = get_response(request)\r\n\r\n        # Код, вызываемый после представления при каждом запросе.\r\n        return response\r\n\r\n    return middleware</code></pre>\r\n<div><strong>Пользовательский Django Middleware на основе класса:</strong></div>\r\n<pre><code>class ExampleMiddleware:\r\n\r\n    def _init_(self, get_response):\r\n        self.get_response = get_response\r\n\r\n    def _call_(self, request):\r\n\r\n        # Код, вызываемый перед представлением при каждом запросе.\r\n        response = self.get_response(request)\r\n\r\n        # Код, вызываемый после представления при каждом запросе.\r\n        return response\r\n\r\n    def process_view(request, view_func, view_args, view_kwargs):\r\n        # Код, вызываемый непосредственно перед кодом представления.\r\n\r\n    def process_exception(request, exception):\r\n        # Код, вызываемый при выбросе исключения.\r\n\r\n    def process_template_response(request, response):\r\n        # Код, вызываемый при наличии в запросе метода render().\r\n        return response</code></pre>\r\n<div>Напоследок перейдите в корневую директорию проекта и добавьте ваше новое пользовательское промежуточное ПО в список&nbsp;<code>MIDDLEWARE</code>&nbsp;из модуля&nbsp;<code>settings.py</code>:</div>\r\n<pre><code>MIDDLEWARE = [\r\n    &hellip;\r\n    'your_app.middleware_directory.custom_middleware_file.CustomMiddleware_class',\r\n]</code></pre>\r\n<div>Добавление пользовательского Middleware в файл settings.py56/2</div>",
      "lesson": 19,
      "ordering_number": 20,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 81,
    "fields": {
      "name": "56.3 Специальные методы Django Middleware на основе классов",
      "content": "<p><em>Специальные методы Django Middleware на основе&nbsp;классов</em></p>\r\n<ul>\r\n<li><code>process_request</code>:<br>когда&nbsp;<em>Django</em>&nbsp;проходит через метод&nbsp;<code>process_request</code>&nbsp;в каждом из&nbsp;<em>Middleware,</em>&nbsp;то<em>&nbsp;</em>с помощью константы&nbsp;<code>ROOT_URLCONF</code>&nbsp;, указанной в&nbsp;<code>settings.py</code>, создаётся объект запроса. После обхода всех связующих ПО по очереди сверху вниз,<em>&nbsp;Django</em>&nbsp;решает, какое из представлений вызвать непосредственно следом за созданием объекта запроса.</li>\r\n<li><code>process_view(request, view_func, view_args, view_kwargs)</code>:&nbsp;<br>рассмотрим формальные параметры, где&nbsp;<code>request</code>&nbsp; &mdash;  это объект-экземпляр&nbsp;<code>HttpRequest</code>, а&nbsp;<code>view_func</code>&nbsp; &mdash;  это функция, которая вызывается непосредственно перед представлением.</li>\r\n<li><code>process_response</code>:&nbsp;<br>данный метод составляет ответ, объект-экземпляр класса&nbsp;<code>HttpResponse</code>&nbsp; &mdash;  конечный результат, получаемый после выполнения&nbsp;<code>process_response</code>в каждом из связующих ПО.</li>\r\n<li><code>process_template_response(request, response)</code>:&nbsp;<br>среди формальных параметров&nbsp;<code>request</code>&nbsp; &mdash;  это объект-экземпляр класса&nbsp;<code>HttpRequest</code>, а&nbsp;<code>response</code>&nbsp; &mdash;  это объект-экземпляр класса&nbsp;<code>TemplateResponse</code>&nbsp;(или эквивалент), ранее возвращенный представлением&nbsp;<em>Django</em>&nbsp;или другим связующим ПО.</li>\r\n<li><code>process_exception(request, exception)</code>:&nbsp;<br>данный метод вызывается, когда представление выбрасывает исключение; обратите внимание на формальные параметры, где&nbsp;<code>request</code>&nbsp; &mdash;  это объект-экземпляр класса&nbsp;<code>HttpRequest</code>, а&nbsp;<code>exception</code>&nbsp; &mdash;  это объект-экземпляр класса&nbsp;<code>Exception</code>, выброшенный функцией или методом представления.</li>\r\n</ul>",
      "lesson": 19,
      "ordering_number": 21,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 82,
    "fields": {
      "name": "56.4 Основные принципы работы Middleware",
      "content": "<p><em>Основные принципы работы Middleware</em></p>\r\n<ul>\r\n<li>При указании связующего программного обеспечения в списке&nbsp;<code>MIDDLEWARE</code>&nbsp;из модуля&nbsp;<code>settings.py</code>&nbsp;<strong>необходимо соблюдать порядок сверху вниз</strong>! Порядок вызова&nbsp;<em>Middleware</em>&nbsp;важен для правильной работы приложений, уделяйте внимание соответствующим указаниям из документации библиотек&nbsp;<em>Django</em>, которые вы подключаете к своему проекту.</li>\r\n<li>Расширять связующее программное обеспечение можно только посредством класса.&nbsp;</li>\r\n<li>Связующее программное обеспечение может как реализовывать, так и не реализовывать различные методы.</li>\r\n<li>Связующее программное обеспечение обязательно реализовывает метод&nbsp;<code>process_request</code>, но никогда НЕ реализовывает методы&nbsp;<code>process_response</code>&nbsp;и&nbsp;<code>process_view</code>.</li>\r\n</ul>",
      "lesson": 19,
      "ordering_number": 22,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 83,
    "fields": {
      "name": "57. Что такое транзакция?",
      "content": "<div>Транзакция &mdash;&nbsp;<strong>это единица работы, затрагивающая набор операций базы данных.</strong></div>\r\n<div>В большинстве случаев выполнять операцию в базе данных нужно лишь после завершения некой другой операции. Например, в банковской системе перевести сумму со счёта А на счёт Б можно только после снятия средств со счёта А.</div>\r\n<div>В транзакции или все операции выполняются, или не выполняется ни одна из них. Таким образом, требуется выполнить все операции в одной транзакции, чтобы она была успешной.</div>\r\n<div>&nbsp;</div>\r\n<div>понятием&nbsp;<em>транзакций</em>&nbsp;и набором требований к транзакционным системам под названием ACID.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Django, высокоуровневый веб-фреймворк, написанный на&nbsp;<a href=\"https://translated.turbopages.org/proxy_u/en-ru.ru.32723b27-66cc9cee-f864714a-74722d776562/https/www.geeksforgeeks.org/python-programming-language/\">Python</a>, предлагает надежный и эффективный способ обработки операций с базой данных.&nbsp;Одним из важных аспектов управления базами данных являются транзакции.&nbsp;В области Django транзакции играют решающую роль в обеспечении согласованности и надежности данных.&nbsp;В этой статье мы рассмотрим концепцию транзакций в Django, углубившись в их преимущества, недостатки, автоматическую фиксацию, точки сохранения, автоматический и неатомный режимы, а также обработку ошибок данных и целостности.</div>\r\n<h2>Что такое транзакции в Django?</h2>\r\n<div>В&nbsp;<a href=\"https://translated.turbopages.org/proxy_u/en-ru.ru.32723b27-66cc9cee-f864714a-74722d776562/https/www.geeksforgeeks.org/django-tutorial/\">Django</a>&nbsp;транзакции относятся к набору операций, которые выполняются как единое целое, обеспечивая согласованность и целостность данных в базе данных.&nbsp;Транзакции позволяют разработчикам группировать несколько запросов к базе данных в единую атомарную операцию, при которой фиксируются либо все изменения, либо ничего вообще.&nbsp;Это помогает избежать частичных обновлений и поддерживать согласованное состояние в случае сбоев.&nbsp;Django предоставляет&nbsp;<a href=\"https://translated.turbopages.org/proxy_u/en-ru.ru.32723b27-66cc9cee-f864714a-74722d776562/https/www.geeksforgeeks.org/what-is-an-api/\">API</a>&nbsp;для управления транзакциями высокого уровня, что позволяет разработчикам явно фиксировать или откатывать транзакции.&nbsp;Используя транзакции, разработчики могут защититься от потенциальных несоответствий данных и гарантировать, что операции с базой данных надежно выполняются контролируемым образом в рамках Django Framework.</div>\r\n<h2>Транзакции Django: преимущества и недостатки</h2>\r\n<div>Транзакции Django обладают значительными преимуществами, предоставляя механизм для объединения нескольких операций с базой данных в единую атомарную единицу, обеспечивая целостность данных.&nbsp;Основное преимущество заключается в возможности поддерживать согласованность состояния базы данных, поскольку в случае сбоя какой-либо части транзакции выполняется откат всей операции.&nbsp;Эта атомарность гарантирует, что база данных остается в надежном состоянии даже при возникновении ошибок.&nbsp;Однако использование транзакций сопряжено с потенциальными недостатками, особенно в случае крупных транзакций, что может привести к проблемам с производительностью, а чрезмерная зависимость от транзакций может привести к взаимоблокировкам, когда несколько транзакций не могут быть выполнены, что влияет на общую эффективность системы.&nbsp;Тщательное рассмотрение компромиссов необходимо для достижения баланса между обеспечением согласованности данных и минимизацией потенциальных недостатков производительности.</div>\r\n<h2>Автоматическая фиксация в Django</h2>\r\n<div>В Django поведение транзакций базы данных по умолчанию - режим автоматической фиксации.&nbsp;В режиме автоматической фиксации каждая операция с базой данных обрабатывается как отдельная транзакция, и изменения немедленно фиксируются в базе данных.&nbsp;Это подходит для простых операций, но для более сложных задач, требующих атомарного выполнения группы операций, разработчикам может потребоваться явное управление транзакциями.</div>\r\n<div>Вот как режим автоматической фиксации выражается в Django с помощью декоратора @transaction.autocommit:</div>\r\n<pre>from django.db import transaction<br>@transaction.autocommit<br>def my_function():<br>    # Your code here<br><br></pre>\r\n<div>В приведенном выше примере функция my_function будет работать в режиме автоматической фиксации. Это означает, что каждая операция с базой данных в функции будет обрабатываться как отдельная транзакция, и изменения будут зафиксированы немедленно. Если во время какой-либо операции с базой данных возникает исключение, изменения, внесенные до возникновения исключения, все равно будут зафиксированы.</div>\r\n</div>",
      "lesson": 19,
      "ordering_number": 23,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 84,
    "fields": {
      "name": "57.1 ACID — это",
      "content": "<div><strong>ACID</strong>&nbsp;&mdash; это набор из четырёх требований к транзакционной системе, обеспечивающих максимально надёжную и предсказуемую работу:</div>\r\n<ol>\r\n<li><strong>Атомарность</strong>&nbsp;(atomicity) &mdash; каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.</li>\r\n<li><strong>Согласованность</strong>&nbsp;(consistency) &mdash; в результате работы транзакции данные будут допустимыми.</li>\r\n<li><strong>Изолированность</strong>&nbsp;(isolation) &mdash; параллельные транзакции не будут оказывать влияния на результат других транзакций.</li>\r\n<li><strong>Долговечность</strong> (durability) &mdash; изменения, получившиеся в результате транзакции, должны оставаться сохранёнными вне зависимости от каких-либо сбоев.</li>\r\n</ol>",
      "lesson": 19,
      "ordering_number": 24,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 85,
    "fields": {
      "name": "58. Для чего используется виртуальная среда разработки?",
      "content": "<div>Виртуальное окружение Python (Python virtual environment) &ndash; это инструмент, позволяющий создавать изолированные среды для выполнения и разработки приложений на языке Python.</div>\r\n<div>С помощью виртуального окружения Python можно установить и использовать различные версии пакетов и зависимостей для каждого проекта, изолируя их друг от друга и предотвращая конфликты или несовместимости.</div>",
      "lesson": 19,
      "ordering_number": 25,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 86,
    "fields": {
      "name": "58.1 виртуальная среда разработки инициализация?",
      "content": "<div>Чтобы создать виртуальное окружение, используем встроенный модуль&nbsp;\r\n<pre><code>venv</code>:</pre>\r\n</div>\r\n<div>\r\n<pre><code># Для Windows\r\npython -m venv venv\r\n# Для Linux, macOS\r\npython3 -m venv venv</code></pre>\r\n<pre><code>&nbsp;</code></pre>\r\n<pre>&nbsp;</pre>\r\n<div>Poetry&nbsp;&mdash; это аналог встроенного менеджера пакетов pip.</div>\r\n<pre>&nbsp;</pre>\r\n<div>Устанавливается следующими командами:</div>\r\n<pre>&nbsp;</pre>\r\n<div>\r\n<pre><code># Windows\r\npip install poetry\r\n# macOS\r\nbrew install poetry  \r\n# Linux, macOS\r\ncurl -sSL https://install.python-poetry.org | python3 -\r\nexport PATH=\"$HOME/.local/bin:$PATH\"</code></pre>\r\n</div>\r\n<pre>&nbsp;</pre>\r\n<div>Подробнее о способах установки читайте по ссылке:&nbsp;<a href=\"https://python-poetry.org/docs/#installation\">https://python-poetry.org/</a>.</div>\r\n<pre>&nbsp;</pre>\r\n<h3>Начало работы с Poetry. Структура toml-файла</h3>\r\n<pre>&nbsp;</pre>\r\n<div>Если у вас уже есть проект с кодом, то вы можете добавить Poetry к проекту следующим образом:</div>\r\n<pre>&nbsp;</pre>\r\n<div>\r\n<pre><code>poetry init</code></pre>\r\n</div>\r\n<pre>&nbsp;</pre>\r\n</div>",
      "lesson": 19,
      "ordering_number": 26,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 87,
    "fields": {
      "name": "59. Для чего служит конструкция try/except? Какие дополнительные возможности есть в этой конструкции?",
      "content": "<div><strong>Конструкция try/except в Python служит для обработки исключений и выполнения кода в зависимости от типа исключения.</strong></div>\r\n<div>Она позволяет &laquo;отлавливать&raquo; исключения и выполнять необходимые действия в зависимости от их типа.</div>\r\n<div>Кроме того, конструкция try/except имеет два опционных блока:</div>\r\n<ol>\r\n<li><strong>Блок finally</strong>&nbsp;выполняется всегда, независимо от того, было исключение или нет.</li>\r\n<li><strong>Блок else</strong> нужен, чтобы выполнить необходимые инструкции только в том случае, если исключения не вызывались.</li>\r\n</ol>",
      "lesson": 19,
      "ordering_number": 27,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 88,
    "fields": {
      "name": "60. Что такое __new__ и __init__?",
      "content": "<div>При создании объекта в Python, например экземпляра класса, происходит два важных этапа: создание экземпляра и его инициализация. Первый этап выполняется методом&nbsp;<strong>new</strong>(), а второй &mdash;&nbsp;<strong>init</strong>().</div>\r\n<div>Рассмотрим пример:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n<div>9</div>\r\n<div>10</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>class</code>&nbsp;<code>MyClass:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>__new__(</code><code>cls</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Метод __new__ вызван\"</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>instance&nbsp;</code><code>=</code>&nbsp;<code>super</code><code>().__new__(</code><code>cls</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>instance</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>__init__(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>\"Метод __init__ вызван\"</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>obj&nbsp;</code><code>=</code>&nbsp;<code>MyClass()</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Вывод:</div>\r\n<pre><code>Метод __new__ вызван\r\nМетод __init__ вызван\r\n</code></pre>\r\n<div>Метод&nbsp;<strong>new</strong>() вызывается при создании нового экземпляра класса. Он отвечает за выделение памяти под новый объект и возвращает этот объект.&nbsp;<strong>new</strong>() является статическим методом и должен возвращать экземпляр класса.</div>\r\n<div>С другой стороны, метод&nbsp;<strong>init</strong>() вызывается после&nbsp;<strong>new</strong>(), когда объект уже создан. Он отвечает за инициализацию этого объекта, то есть задаёт начальные значения его атрибутов.</div>\r\n<div>Следовательно,&nbsp;<strong>init</strong>() всегда вызывается после&nbsp;<strong>new</strong>(), так как объект должен быть создан перед тем, как он будет инициализирован.</div>\r\n<div>Это поведение является стандартным для Python и в большинстве случаев не требует изменений. Однако, если по какой-то причине требуется изменить этот процесс, можно переопределить методы&nbsp;<strong>new</strong>() и&nbsp;<strong>init</strong>(). Например, можно предотвратить вызов&nbsp;<strong>init</strong>() после&nbsp;<strong>new</strong>() путём возвращения другого объекта из метода&nbsp;<strong>new</strong>().</div>",
      "lesson": 19,
      "ordering_number": 28,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 89,
    "fields": {
      "name": "42. Какие режимы доступов в наследовании классов существуют?",
      "content": "<div>В Python существуют следующие режимы доступов к атрибутам и методам классов:</div>\r\n<ol>\r\n<li><strong>Публичные атрибуты и методы</strong>&nbsp;&mdash; доступны всем наследникам и создаются простым определением их в теле класса без особых префиксов.</li>\r\n<li><strong>Приватные атрибуты и методы</strong>&nbsp;&mdash; доступны только внутри того класса, где они были определены. Создаются путём добавления двойного подчёркивания (__) перед именем атрибута или метода.</li>\r\n<li><strong>Защищённые атрибуты и методы</strong> &mdash; смесь между публичными и приватными. Создаются путём добавления одного подчёркивания (_) перед именем атрибута или метода. Используются, когда разработчик хочет запретить доступ снаружи объекта, но дать возможность работать с ними внутри объекта класса-наследника или суперкласса.</li>\r\n</ol>",
      "lesson": 18,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 90,
    "fields": {
      "name": "43. setarrt, getarrt, delattr – что это такое",
      "content": "<div><strong>Встроенные функции Python для работы с атрибутами объектов:</strong></div>\r\n<ol>\r\n<li><strong>hasattr()</strong>&nbsp;&mdash; проверяет наличие атрибута.</li>\r\n<li><strong>getattr()</strong>&nbsp;&mdash; получает значение атрибута.</li>\r\n<li><strong>setattr()</strong>&nbsp;&mdash; присваивает значение атрибуту.</li>\r\n<li><strong>delattr()</strong>&nbsp;&mdash; удаляет именованный атрибут.</li>\r\n</ol>\r\n<div>Атрибут &mdash; это переменная, которая связана с объектом и хранит в себе какие-то данные.</div>",
      "lesson": 18,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 91,
    "fields": {
      "name": "44. Где используется библиотека pytest?",
      "content": "<h2>Что такое автоматическое тестирование?</h2>\r\n<div>Автоматическое тестирование &ndash; это процесс проверки корректности работы программы с помощью автоматически выполняемых тестов. Такие тесты обычно представляют собой набор функций или методов, которые вызывают тестируемый код и проверяют его результаты. 🧪</div>\r\n<h2>Библиотека unittest</h2>\r\n<div><code>unittest</code>&nbsp;&ndash; это стандартная библиотека Python для создания и выполнения тестов. Она предоставляет множество полезных функций для проверки различных аспектов работы кода. Вот пример теста, созданного с использованием&nbsp;<code>unittest</code>:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n<div>9</div>\r\n<div>10</div>\r\n<div>11</div>\r\n<div>12</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>import</code>&nbsp;<code>unittest</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>def</code>&nbsp;<code>add(a, b):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>a&nbsp;</code><code>+</code>&nbsp;<code>b</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>class</code>&nbsp;<code>TestAddition(unittest.TestCase):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>test_add(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>self</code><code>.assertEqual(add(</code><code>2</code><code>,&nbsp;</code><code>3</code><code>),&nbsp;</code><code>5</code><code>)</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>self</code><code>.assertEqual(add(</code><code>-</code><code>1</code><code>,&nbsp;</code><code>1</code><code>),&nbsp;</code><code>0</code><code>)</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>if</code>&nbsp;<code>__name__&nbsp;</code><code>=</code><code>=</code>&nbsp;<code>'__main__'</code><code>:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unittest.main()</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере мы создаем функцию&nbsp;<code>add()</code>, которая выполняет сложение двух чисел. Затем мы создаем класс&nbsp;<code>TestAddition</code>, наследуемый от&nbsp;<code>unittest.TestCase</code>, и определяем в нем метод&nbsp;<code>test_add()</code>, который проверяет корректность работы функции&nbsp;<code>add()</code>&nbsp;с помощью метода&nbsp;<code>assertEqual()</code>.</div>\r\n<h2>Библиотека pytest</h2>\r\n<div><code>pytest</code>&nbsp;&ndash; это популярная сторонняя библиотека для тестирования на Python. Она предоставляет более простой и гибкий синтаксис для создания тестов, чем&nbsp;<code>unittest</code>. Вот пример теста, созданного с использованием&nbsp;<code>pytest</code>:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>import</code>&nbsp;<code>pytest</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>def</code>&nbsp;<code>add(a, b):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code>&nbsp;<code>a&nbsp;</code><code>+</code>&nbsp;<code>b</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>def</code>&nbsp;<code>test_add():</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>assert</code>&nbsp;<code>add(</code><code>2</code><code>,&nbsp;</code><code>3</code><code>)&nbsp;</code><code>=</code><code>=</code>&nbsp;<code>5</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>assert</code>&nbsp;<code>add(</code><code>-</code><code>1</code><code>,&nbsp;</code><code>1</code><code>)&nbsp;</code><code>=</code><code>=</code>&nbsp;<code>0</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Как видите, синтаксис&nbsp;<code>pytest</code>&nbsp;более лаконичен, и не требует создания отдельного класса для тестов. Вместо этого, тесты представляют собой функции, имена которых начинаются с&nbsp;<code>test_</code>. Для проверки результатов используются обычные операторы&nbsp;<code>assert</code>.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<ol>\r\n<li>Создать пакет&nbsp;\r\n<pre><code>tests</code>&nbsp;(директорию с файлом&nbsp;__init__.py&nbsp;внутри).</pre>\r\n</li>\r\n<li>Создать в этом пакете файл&nbsp;\r\n<pre><code>test_module.py</code></pre>\r\n, где&nbsp;\r\n<pre><code>module</code>&nbsp;&mdash; обычно название тестируемого модуля.</pre>\r\n</li>\r\n<li>В файле&nbsp;\r\n<pre><code>test_module.py</code></pre>\r\n&nbsp;написать функции, начинающиеся с префикса test_.</li>\r\n</ol>\r\n<div>&nbsp;</div>\r\n</div>\r\n<div>Фикстуры&nbsp;&mdash; это функции, в которых используется декоратор @pytest.fixture,<br>&nbsp;- которые выполняются перед каждым тестом<br>- и которые позволяют передать на вход тестовой функции тестовые данные.</div>",
      "lesson": 18,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 92,
    "fields": {
      "name": "45. За что отвечают команды git revert и git reset? Чем они отличаются?",
      "content": "<p>Если кратко, то различие между git revert и git reset в том, что&nbsp;<strong>git reset переносит вас на определённую точку в истории коммитов,<br>a git revert создаёт новый коммит с отменой изменений</strong>.<br><br>&nbsp;Revert. $ git revert используется для добавления нового коммита, который отменяет изменения, сделанные в другом коммите. В отличие от git reset, не изменяет историю коммитов.<br><br>&nbsp;Команда revert считается безопасной операцией для публичных отмен, поскольку добавляет в историю новые данные, которыми можно делиться удаленно, а не перезаписывает старые, от которых могут зависеть участники команды.</p>",
      "lesson": 18,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 93,
    "fields": {
      "name": "46. Что такое REST?  Это позволяет ...  Акроним ...",
      "content": "<div>\r\n<p><strong>REST</strong>&nbsp;&mdash; это архитектурный подход, который устанавливает ограничения для API:</p>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>- как они должны быть устроены</li>\r\n<li>- и какие функции поддерживать.</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>\r\n<p><br><br></p>\r\n<div>Это позволяет стандартизировать работу программных интерфейсов,<br>сделать их более удобными и производительными.</div>\r\n<p><br><br></p>\r\n<div>Слово REST &mdash; акроним от Representational State Transfer, что переводится на русский как &laquo;передача состояния представления&raquo;, &laquo;передача репрезентативного состояния&raquo; или &laquo;передача &bdquo;самоописываемого&ldquo; состояния&raquo;.</div>\r\n<p><br><br></p>\r\n<div><strong>Основные принципы архитектуры REST:</strong></div>\r\n<div>\r\n<ul>\r\n<li style=\"list-style-type: none;\">\r\n<ul>\r\n<li>&mdash; клиент-серверная модель;</li>\r\n<li>&mdash; отсутствие состояния;</li>\r\n<li>&mdash; кэширование;</li>\r\n<li>&mdash; единообразие интерфейса;</li>\r\n<li>&mdash; многоуровневая система;</li>\r\n<li>&mdash; код по требованию (необязательно).</li>\r\n</ul>\r\n</li>\r\n</ul>\r\n</div>",
      "lesson": 18,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 94,
    "fields": {
      "name": "46.1 Основные принципы архитектуры REST:",
      "content": "<div><strong>Основные принципы архитектуры REST:</strong></div>\r\n<div>&mdash; клиент-серверная модель;<br>&mdash; отсутствие состояния;<br>&mdash; кэширование;<br>&mdash; единообразие интерфейса;<br>&mdash; многоуровневая система;<br>&mdash; код по требованию (необязательно).</div>",
      "lesson": 18,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 95,
    "fields": {
      "name": "46.2  REST API: что это такое и как работает",
      "content": "<div>\r\n<div>\r\n<ul>\r\n<li>REST API: что это такое и&nbsp;как работает</li>\r\n</ul>\r\n</div>\r\n<div>\r\n<div>Рассказываем о&nbsp;самом распространённом архитектурном стиле, который позволяет программам общаться по&nbsp;сети.</div>\r\n</div>\r\n</div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<div>\r\n<div>Когда вы&nbsp;заходите на&nbsp;сайт, браузер отправляет запрос на&nbsp;сервер, получает от&nbsp;него ответ и&nbsp;выводит нужную страницу. Но&nbsp;у&nbsp;всех сайтов&nbsp;&mdash; разные серверы, информация на&nbsp;которых хранится по-разному.</div>\r\n<div>Чтобы браузер понимал, что именно ему нужно запросить, а&nbsp;сервер&nbsp;&mdash; что ответить, используют API, или программные интерфейсы приложений.&nbsp;</div>\r\n<div>API могут быть разными. Самый востребованный из&nbsp;них&nbsp;&mdash; REST. О&nbsp;нём и&nbsp;пойдёт речь в&nbsp;этой статье.</div>\r\n</div>\r\n</div>\r\n<div>\r\n<h2><strong>Что такое REST API</strong></h2>\r\n<div><strong>REST API&nbsp;</strong>&mdash;&nbsp;это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и&nbsp;какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их&nbsp;более удобными и&nbsp;производительными.</div>\r\n<div>Слово REST&nbsp;&mdash; акроним от&nbsp;Representational State Transfer, что переводится на&nbsp;русский как &laquo;передача состояния представления&raquo;, &laquo;передача репрезентативного состояния&raquo; или &laquo;передача &bdquo;самоописываемого&ldquo; состояния&raquo;.</div>\r\n<div>В&nbsp;отличие от, например, SOAP API, REST API&nbsp;&mdash; не&nbsp;протокол, а&nbsp;простой список рекомендаций, которым можно следовать или не&nbsp;следовать. Поэтому у&nbsp;него нет собственных методов. С&nbsp;другой стороны, его автор Рой Филдинг создал ещё и&nbsp;<a href=\"https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&amp;utm_medium=link&amp;utm_campaign=all_all_media_links_links_articles_all_all_skillbox\">протокол HTTP</a>, так что они очень хорошо сочетаются, и&nbsp;REST обычно используют в&nbsp;связке с&nbsp;HTTP. Хотя новичкам нужно помнить:&nbsp;<strong>REST&nbsp;&mdash; это не&nbsp;только HTTP, а&nbsp;HTTP&nbsp;&mdash; не&nbsp;только REST</strong>.</div>\r\n<div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Читайте также:</div>\r\n<div><a href=\"https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&amp;utm_medium=link&amp;utm_campaign=all_all_media_links_links_articles_all_all_skillbox\">Что такое HTTP и&nbsp;зачем он&nbsp;нужен</a></div>\r\n</div>\r\n</div>\r\n<div>Иногда, помимо акронима REST, можно встретить слово&nbsp;<strong>RESTful</strong>. Это не&nbsp;термин, но&nbsp;в&nbsp;сообществе его применяют к&nbsp;веб-сервисам, которые соответствуют REST-архитектуре. RESTful используют как прилагательное.</div>\r\n</div>\r\n<div>\r\n<h2><strong>Как работает REST API: 6&nbsp;принципов архитектуры</strong></h2>\r\n<div>Всего в&nbsp;REST есть шесть требований к&nbsp;проектированию&nbsp;API. Пять из&nbsp;них обязательные, одно&nbsp;&mdash; опциональное:</div>\r\n<ul>\r\n<li>Клиент-серверная модель (client-server model).</li>\r\n<li>Отсутствие состояния (statelessness).</li>\r\n<li>Кэширование (cacheability).</li>\r\n<li>Единообразие интерфейса (uniform interface).</li>\r\n<li>Многоуровневая система (layered system).</li>\r\n<li>Код по&nbsp;требованию (code on&nbsp;demand)&nbsp;&mdash; необязательно.</li>\r\n</ul>\r\n<div>Чтобы разобраться в&nbsp;них подробнее, нужно понимать, что в&nbsp;вебе называют ресурсами.&nbsp;<strong>Ресурсы</strong>&nbsp;&mdash; это любые данные: текст, изображение, видео, аудио, целая программа. Например,&nbsp;<a href=\"https://skillbox.ru/media/code/chto_takoe_html/?utm_source=media&amp;utm_medium=link&amp;utm_campaign=all_all_media_links_links_articles_all_all_skillbox\">HTML веб-страницы</a>, на&nbsp;которой вы&nbsp;сейчас находитесь,&nbsp;&mdash; тоже ресурс.</div>\r\n<h3><strong>Клиент-серверная модель</strong></h3>\r\n<div>Это требование отделяет друг от&nbsp;друга два понятия: клиент и&nbsp;сервер.</div>\r\n<div><strong>Сервер&nbsp;</strong>&mdash;&nbsp;программа, в&nbsp;которой хранятся и&nbsp;обрабатываются ресурсы. Сервер может располагаться на&nbsp;одном или нескольких компьютерах; но даже в&nbsp;одном компьютере может быть несколько виртуальных серверов. Допустим, изначально HTML-код этой статьи хранился где-то на&nbsp;серверах Skillbox.</div>\r\n<div><strong>Клиент&nbsp;</strong>&mdash;&nbsp;программа, которая запрашивает у&nbsp;сервера доступ к&nbsp;ресурсам. Для этого она использует&nbsp;API. Когда ваш браузер запрашивает у&nbsp;сервера Skillbox эту веб-страницу, он&nbsp;выступает в&nbsp;роли клиента.</div>\r\n<div>Получается структура, при которой клиент направляет к&nbsp;серверу запрос, а&nbsp;в&nbsp;ответ получает ресурсы. Такое разделение позволяет создавать клиент и&nbsp;сервер независимо друг от&nbsp;друга, что ускоряет и&nbsp;упрощает разработку.</div>\r\n<div><img src=\"http://127.0.0.1:55104/09194607122022_5c20dcbcfbab07ab6c2df7e27444d5ac2afca569.png\"></div>\r\n<em>Изображение: Майя Мальгина для Skillbox Media</em>\r\n<div>Представим, что вы&nbsp;делаете сервис для учёта деловых переписок. Сами переписки хранятся на&nbsp;сервере, а&nbsp;доступ к&nbsp;ним можно получить из&nbsp;мобильного приложения. Оно не&nbsp;будет хранить никаких данных&nbsp;&mdash; только отправлять запросы на&nbsp;сервер, получать ответы и&nbsp;отображать их&nbsp;на&nbsp;экране смартфона.</div>\r\n<div>Если вы&nbsp;когда-нибудь захотите полностью изменить логику работы сервера, то&nbsp;это никак не&nbsp;отразится на&nbsp;мобильном приложении. До&nbsp;тех пор, пока они понимают запросы и&nbsp;ответы друг друга, конечно.</div>\r\n<div>А&nbsp;чтобы дать доступ к&nbsp;сервису из&nbsp;десктопного приложения и&nbsp;личного сайта, достаточно написать два новых клиента&nbsp;&mdash; а&nbsp;на&nbsp;сервере ничего менять не&nbsp;надо. Такая вот гибкость.</div>\r\n<div><img src=\"http://127.0.0.1:55104/09194607122022_278cadb5c5a600fd354bbb4a32acf34407bf98f0.png\"></div>\r\n<em>Изображение: Майя Мальгина для Skillbox Media</em>\r\n<h3><strong>Отсутствие состояния</strong></h3>\r\n<div>Второй принцип настолько важен, что даже отражён в&nbsp;названии архитектурного стиля&nbsp;&mdash;&nbsp;<strong>Representational State Transfer</strong>. Это значит, что на&nbsp;сервере не&nbsp;хранится никаких данных о&nbsp;прошлых взаимодействиях с&nbsp;клиентом&nbsp;&mdash; каждый запрос должен содержать всю информацию для его обработки.</div>\r\n<div>Например, кто-то запросил последнее сообщение от&nbsp;ООО &laquo;Рога и&nbsp;копыта&raquo;. В&nbsp;этом запросе содержится вся информация, которая нужна серверу, чтобы дать корректный ответ.</div>\r\n<div>Если клиент потом хочет получить предпоследнее сообщение, то&nbsp;он&nbsp;не&nbsp;может просто сказать: &laquo;Дай мне соседний ресурс&raquo;&nbsp;&mdash; ему нужно заново составить полный запрос по&nbsp;всем правилам.</div>\r\n<div>Это снижает нагрузку на&nbsp;сервер, что особенно полезно, если к&nbsp;нему подключено одновременно много клиентов. Не&nbsp;нужно хранить дополнительную информацию о&nbsp;прошлых обращениях каждого из&nbsp;них. Достаточно обработать каждый запрос в&nbsp;отдельности.</div>\r\n<div>\r\n<div>\r\n<div>Даже если какой-то из&nbsp;предыдущих запросов потеряется, это не&nbsp;сломает логику взаимодействия клиента и&nbsp;сервера, потому что каждый запрос самодостаточен.</div>\r\n</div>\r\n</div>\r\n<h3><strong>Кэширование</strong></h3>\r\n<div>Иногда клиент запрашивает с&nbsp;сервера одни и&nbsp;те&nbsp;же данные по&nbsp;несколько раз&nbsp;&mdash; например, вы&nbsp;постоянно обращаетесь к&nbsp;какому-нибудь важному письму в&nbsp;сервисе для учёта деловых переписок.</div>\r\n<div>Если при каждом таком запросе сервер будет с&nbsp;нуля собирать нужные данные и&nbsp;отправлять их&nbsp;клиенту, нагрузка на&nbsp;систему повысится&nbsp;&mdash; особенно когда таких повторов много. Решением проблемы в&nbsp;REST API стало&nbsp;<strong>кэширование</strong>, то&nbsp;есть сохранение части данных у&nbsp;клиента или на&nbsp;промежуточных серверах.</div>\r\n<div>Однако тут тоже важно подойти к&nbsp;делу без излишнего фанатизма и&nbsp;не&nbsp;кэшировать всю информацию подряд. Во-первых, для этого потребовались&nbsp;бы слишком большие объёмы памяти. Во-вторых, какие-то данные (скажем, количество исходящих писем) со&nbsp;временем могут устаревать&nbsp;&mdash; зачем&nbsp;же держать этот неактуальный хлам в&nbsp;кэше? Именно поэтому в&nbsp;каждом ответе сервера на&nbsp;запрос есть пометка о&nbsp;том, можно&nbsp;ли его кэшировать.</div>\r\n<h3><strong>Единообразие интерфейса</strong></h3>\r\n<div>Должен быть&nbsp;<strong>единый способ обращения&nbsp;</strong>к&nbsp;каждому ресурсу. Например, мы&nbsp;хотим добавить в&nbsp;наш сервис новую функциональность для просмотра данных о&nbsp;денежных переводах. Понятно, что логика интерфейса для обращения к&nbsp;ним должна быть такой&nbsp;же, как и&nbsp;для всего, что было в&nbsp;сервисе раньше.</div>\r\n<div>Файлы обычно передаются клиенту не&nbsp;в&nbsp;том виде, в&nbsp;котором хранятся на&nbsp;сервере. В&nbsp;вебе их&nbsp;часто преобразуют в&nbsp;JSON или XML и&nbsp;только потом отправляют клиенту. Ответ на&nbsp;запросы к&nbsp;новому ресурсу должен приходить в&nbsp;том&nbsp;же формате, что и&nbsp;к&nbsp;старым, и&nbsp;сразу&nbsp;же содержать дополнительную информацию: что разрешается делать с&nbsp;ресурсом, можно&nbsp;ли его изменять и&nbsp;удалять на&nbsp;сервере и&nbsp;так далее.</div>\r\n<div>Для реализации единообразного интерфейса в&nbsp;REST API используется принцип&nbsp;<strong>HATEOAS</strong>&nbsp;(Hypermedia as&nbsp;the Engine of&nbsp;Application State).</div>\r\n<h3><strong>Многоуровневая система</strong></h3>\r\n<div>До&nbsp;сих пор мы&nbsp;рассматривали сервер как единую сущность. Но&nbsp;его структура куда сложнее. Между ним и&nbsp;клиентом есть несколько промежуточных узлов, выполняющих вспомогательные функции,&nbsp;&mdash;&nbsp;<strong>прокси-серверы</strong>.</div>\r\n<div>Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных. Если основных серверов несколько, то&nbsp;дополнительные серверы-балансировщики могут распределять нагрузку между ними и&nbsp;решать, в&nbsp;какой из&nbsp;них направлять запрос:</div>\r\n<div><img src=\"http://127.0.0.1:55104/09194607122022_bd473197c461193ea9b6d317f4c236910d065887.png\" width=\"795\" height=\"319\"></div>\r\n<br>\r\n<div>Никто из&nbsp;участников цепочки не&nbsp;знает всего пути, который проходит запрос, &mdash; только своих &laquo;соседей&raquo; справа и&nbsp;слева. Ни&nbsp;клиент, ни&nbsp;один из&nbsp;прокси-серверов не&nbsp;знает, к&nbsp;кому он&nbsp;обращается&nbsp;&mdash; к основному сервису или к другому прокси. В&nbsp;REST API это работает в&nbsp;обе стороны: никакие серверы (ни&nbsp;основные, ни&nbsp;прокси) не&nbsp;знают, кому отправляют ответ и&nbsp;уходит&nbsp;ли он&nbsp;куда-то дальше.</div>\r\n<h3><strong>Код по&nbsp;требованию (необязательно)</strong></h3>\r\n<div>Этот принцип означает, что сервер в&nbsp;ответ на&nbsp;запрос может&nbsp;<strong>отправить исходный код</strong>, который выполняется уже на&nbsp;стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на&nbsp;JavaScript.</div>\r\n<div>В&nbsp;REST API требование необязательно, потому что не&nbsp;всем сайтам и&nbsp;сервисам нужно умение работать с&nbsp;готовыми скриптами.</div>\r\n</div>\r\n<div>\r\n<div>\r\n<h2><strong>Методы REST API</strong></h2>\r\n<div>Так как REST&nbsp;&mdash; архитектурный подход, а&nbsp;не&nbsp;протокол, в&nbsp;нём не&nbsp;заложено никаких конкретных методов. Но&nbsp;чаще всего его применяют вместе со&nbsp;стандартом&nbsp;<strong>HTTP</strong>, в котором заложены собственные методы.</div>\r\n<div>Если кратко, то&nbsp;в&nbsp;HTTP прописан набор действий, который можно описать аббревиатурой&nbsp;<strong>CRUD</strong>: create&nbsp;&mdash; &laquo;создать&raquo;, read&nbsp;&mdash; &laquo;прочитать&raquo;, update&nbsp;&mdash; &laquo;обновить&raquo;, delete&nbsp;&mdash; &laquo;удалить&raquo;.</div>\r\n<div>Для каждого такого действия существуют один или несколько глаголов&nbsp;&mdash; это и&nbsp;есть методы. Например, GET для чтения, а&nbsp;PUT и&nbsp;PATCH&nbsp;&mdash; для разных видов обновления. Глагол-метод применяется к&nbsp;URL-адресу нужного ресурса, который в&nbsp;&laquo;предложении&raquo; выполняет роль существительного.</div>\r\n<div>Подробнее о&nbsp;работе протокола HTTP и&nbsp;его методов вы&nbsp;можете прочесть в&nbsp;<a href=\"https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&amp;utm_medium=link&amp;utm_campaign=all_all_media_links_links_articles_all_all_skillbox\">нашей статье</a>.</div>\r\n</div>\r\n</div>\r\n<div>\r\n<div>\r\n<h2><strong>Для чего используют REST API</strong></h2>\r\n<div>Архитектурный стиль REST&nbsp;&mdash; самый распространённый подход к&nbsp;проектированию&nbsp;API. Вот в&nbsp;каких случаях его применяют:</div>\r\n<ul>\r\n<li>пропускная способность соединения с&nbsp;сервером ограничена;</li>\r\n<li>нужно соединить мобильные приложения с&nbsp;серверными;</li>\r\n<li>проект разбит на&nbsp;микросервисы;</li>\r\n<li>сервис предоставляет свои возможности другим разработчикам;</li>\r\n<li>используется AJAX;</li>\r\n<li>известно, что систему нужно будет масштабировать.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n<div>\r\n<div>\r\n<h2><strong>Итоги</strong></h2>\r\n<div>Как мы&nbsp;видим, REST API не&nbsp;случайно стал таким популярным. Повторим основные его отличия:</div>\r\n<ul>\r\n<li><strong>REST&nbsp;&mdash; это архитектурный стиль API.</strong>&nbsp;Он&nbsp;не&nbsp;ограничивается никакими протоколами и&nbsp;не&nbsp;имеет собственных методов. Но&nbsp;обычно в&nbsp;RESTful-сервисах используют стандарт HTTP, а&nbsp;файлы передают в&nbsp;формате JSON или&nbsp;XML.</li>\r\n<li>Есть&nbsp;<strong>шесть принципов</strong>, на&nbsp;которых строится REST: клиент-серверная модель, отсутствие состояния, кэширование, единообразие интерфейса, многоуровневая система, код по&nbsp;требованию. Последний из&nbsp;них необязателен.</li>\r\n<li><strong>REST-подход к&nbsp;архитектуре</strong> позволяет сделать сервисы отказоустойчивыми, гибкими и&nbsp;производительными, а&nbsp;при их&nbsp;масштабировании и&nbsp;внесении изменений не&nbsp;возникает больших сложностей.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>",
      "lesson": 18,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 96,
    "fields": {
      "name": "47. Какие операторы для фильтрации и сортировки данных тебе известны",
      "content": "<p>Основные методы сортировки в Python<br>Python предоставляет несколько встроенных методов для сортировки данных, таких как sorted() и метод .sort() для списков.<br>&nbsp;Эти методы работают с любыми итерируемыми объектами, включая списки, кортежи и строки.<br>С их помощью можно легко упорядочить данные по возрастанию или убыванию.<br><br>Метод sorted()<br>Функция sorted() возвращает новый отсортированный список из элементов итерируемого объекта, не изменяя оригинальный объект.<br>Это особенно полезно, когда необходимо сохранить исходные данные без изменений.<br>Python<br>Скопировать код<br># Пример использования sorted()<br>numbers = [4, 2, 9, 1]<br>sorted_numbers = sorted(numbers)<br>print(sorted_numbers)&nbsp; # Вывод: [1, 2, 4, 9]<br><br><br>Метод .sort()<br><br>Метод .sort() используется для сортировки списка на месте, то есть он изменяет оригинальный список. Это может быть полезно, когда нужно изменить данные непосредственно в исходном объекте.<br>Python<br>Скопировать код<br># Пример использования .sort()<br>numbers = [4, 2, 9, 1]<br>numbers.sort()<br>print(numbers)&nbsp; # Вывод: [1, 2, 4, 9]<br><br><br>Функция Filter используется для фильтрации элементов в данном списке элементов с помощью предиката.<br>Предикат - это функция, которая всегда возвращает True или False,<br>выполняя некоторые операции с условиями в методе filter<br>Синтаксис:<br>filter(predicate, list)<br>где,<br>список - это входной список<br>предикат - это условие, которое должно выполняться для данного списка<br>Метод 1: использование лямбды в качестве предиката<br>Здесь lambda используется для вычисления выражения, которое действует как предикат.<br>Синтаксис:<br>filter(lambda x: condition, list)<br>где<br>список - это входной список<br>условие действует как предикат<br>Пример: Фильтровать все четные и нечетные числа в списке<br>Python3<br># create a list of 10 elements<br>data = [10, 2, 3, 4, 56, 32, 56, 32, 21, 59]<br><br># apply a filter that takes only even numbers with<br># lambda as predicate<br>a = filter(lambda x: x % 2 == 0, data)<br><br># display<br>for i in a:<br>&nbsp;&nbsp;&nbsp; print(i)<br><br>print(\"------------\")<br><br><br># apply a filter that takes only odd&nbsp; numbers with<br># lambda as predicate<br>a = filter(lambda x: x % 2 != 0, data)<br><br># display<br>for i in a:<br>&nbsp;&nbsp;&nbsp; print(i)<br>Вывод:<br>10<br>2<br>4<br>56<br>32<br>56<br>32<br>------------<br>3<br>21<br>59</p>",
      "lesson": 18,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 97,
    "fields": {
      "name": "48 Нормальная форма – что это?",
      "content": "<div>\r\n<div><strong>Нормальная форма &mdash; это свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных.</strong></div>\r\n<div>Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение.</div>\r\n<div>Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам, называется нормализацией.</div>\r\n<div>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность. Конечная цель нормализации &mdash; уменьшение потенциальной противоречивости хранимой в базе данных информации.</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>",
      "lesson": 18,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 98,
    "fields": {
      "name": "48.1 Виды нормальных форм",
      "content": "<ol>\r\n<li><strong>1NF</strong>&nbsp;(первая нормальная форма): каждая ячейка таблицы должна содержать одно значение, а каждая запись &mdash; быть уникальной.</li>\r\n<li><strong>2NF</strong>&nbsp;(вторая нормальная форма): избыточные данные из таблицы, которые применяются к нескольким строкам, размещаются в отдельных таблицах.</li>\r\n<li><strong>3NF</strong>&nbsp;(третья нормальная форма): все неключевые атрибуты должны быть полностью функциональны в первичном ключе и независимы друг от друга.</li>\r\n<li><strong>BCNF</strong>&nbsp;(нормальная форма Бойса-Кодда): каждый определитель должен быть потенциальным ключом.</li>\r\n<li><strong>4NF</strong>&nbsp;(четвертая нормальная форма): в записи не должно быть нескольких независимых многозначных фактов об объекте.</li>\r\n<li><strong>5NF</strong>&nbsp;(пятая нормальная форма): информация должна быть реконструирована из более мелких, по-разному организованных фрагментов данных.</li>\r\n<li><strong>6NF</strong>&nbsp;(шестая нормальная форма): обработка временных данных путем дальнейшей декомпозиции таблиц для устранения нетемпоральной избыточности.</li>\r\n</ol>\r\n<div><br>Первая нормальная форма (1НФ) - каждый атрибут должен содержать только одно значение.<br>Вторая нормальная форма (2НФ) - каждый неключевой атрибут должен зависеть от первичного ключа.</div>\r\n<div>Третья нормальная форма (3НФ) - каждый неключевой атрибут должен зависеть только от первичного ключа.</div>",
      "lesson": 18,
      "ordering_number": 11,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 99,
    "fields": {
      "name": "48.2 1NF (первая нормальная форма)",
      "content": "<p><strong>1NF</strong>&nbsp;(первая нормальная форма): каждая ячейка таблицы должна содержать одно значение, а каждая запись &mdash; быть уникальной.<br><br>Первая нормальная форма (1НФ) - каждый атрибут должен содержать только одно значение.</p>",
      "lesson": 18,
      "ordering_number": 12,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 100,
    "fields": {
      "name": "48.3 2NF (вторая нормальная форма):",
      "content": "<p><strong>2NF</strong> (вторая нормальная форма): избыточные данные из таблицы, которые применяются к нескольким строкам, размещаются в отдельных таблицах.</p>",
      "lesson": 18,
      "ordering_number": 13,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 101,
    "fields": {
      "name": "49. Перечисли базовые классы для реализации контроллеров в веб-приложении.",
      "content": "<div>Вот набор основных базовых классов, которые встречаются при работе в Django:</div>\r\n<ul>\r\n<li>&nbsp;CreateView&nbsp;&mdash; отвечает за создание объекта, для него название шаблона должно строиться следующим образом:&nbsp;\r\n<pre><code>&lt;app_name&gt;/&lt;model&gt;_form.html</code></pre>\r\n</li>\r\n<li>&nbsp;DetailView&nbsp;&mdash; отвечает за просмотр деталей объекта, название шаблона для него строится следующим образом:&nbsp;\r\n<pre><code>&lt;app_name&gt;/&lt;model&gt;_detail.html</code></pre>\r\n</li>\r\n<li>&nbsp;UpdateView&nbsp;&mdash; отвечает за редактирование объекта, для него название шаблона строится так:&nbsp;\r\n<pre><code>&lt;app_name&gt;/&lt;model&gt;_form.html</code></pre>\r\n</li>\r\n<li>&nbsp;DeleteView&nbsp;&mdash; отвечает за удаление объекта, для него название шаблона строится следующим образом:&nbsp;\r\n<pre><code>&lt;app_name&gt;/&lt;model&gt;_confirm_delete.html</code></pre>\r\n</li>\r\n<li>&nbsp;ListView&nbsp;&mdash; отвечает за отображение списка объектов, для него название шаблона строится так:&nbsp;\r\n<pre><code>&lt;app_name&gt;/&lt;model&gt;_list.html</code></pre>\r\n</li>\r\n<li>&nbsp;TemplateView &mdash; не отвечает за работу с объектами, но является очень полезным классом для вывода статических страниц с информацией, при этом шаблон нужно указывать вручную.</li>\r\n</ul>",
      "lesson": 18,
      "ordering_number": 14,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 102,
    "fields": {
      "name": "50. За что отвечает dict comprehensions?  Конструкция...",
      "content": "<p>Генераторы словарей (<strong>dict</strong>&nbsp;<strong>comprehension</strong>) &mdash; это метод преобразования одного словаря в другой.<br><br>Во время этого преобразования элементы исходного словаря, соответствующие заданным условиям, включаются в новый словарь. При этом каждый элемент может быть преобразован по мере необходимости.<br><br></p>\r\n<div>Словарное включение (или dictionary comprehension) в Python &mdash; это мощный инструмент, который позволяет создавать словари более элегантно и кратко. Обычно это используется, когда нужно создать словарь, ключи которого получаются из некоторого итерируемого объекта.</div>\r\n<div>Например, представим, что есть некоторый список чисел и необходимо создать словарь, в котором каждому числу соответствует его квадрат. Без словарного включения это можно было бы сделать так:</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>numbers&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>,&nbsp;</code><code>5</code><code>]</code></div>\r\n<div><code>squares&nbsp;</code><code>=</code>&nbsp;<code>{}</code></div>\r\n<div><code>for</code>&nbsp;<code>n&nbsp;</code><code>in</code>&nbsp;<code>numbers:</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>squares[n]&nbsp;</code><code>=</code>&nbsp;<code>n</code><code>*</code><code>*</code><code>2</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Однако словарное включение позволяет сократить этот код до одной строки:</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>numbers&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>,&nbsp;</code><code>5</code><code>]</code></div>\r\n<div><code>squares&nbsp;</code><code>=</code>&nbsp;<code>{n: n</code><code>*</code><code>*</code><code>2</code>&nbsp;<code>for</code>&nbsp;<code>n&nbsp;</code><code>in</code>&nbsp;<code>numbers}</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Словарное включение работает по принципу:&nbsp;<code>{ключ: значение for элемент in итерируемый_объект}</code>.</div>\r\n<div>Также есть возможность задать одно и то же значение для всех ключей. Например, для создания словаря, где каждому числу соответствует значение&nbsp;<code>True</code>, можно использовать такой код:</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>numbers&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>,&nbsp;</code><code>5</code><code>]</code></div>\r\n<div><code>true_dict&nbsp;</code><code>=</code>&nbsp;<code>{n:&nbsp;</code><code>True</code>&nbsp;<code>for</code>&nbsp;<code>n&nbsp;</code><code>in</code>&nbsp;<code>numbers}</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Словарное включение также поддерживает условные конструкции. Например, можно создать словарь, где каждому четному числу соответствует&nbsp;<code>True</code>, а нечетному &mdash;&nbsp;<code>False</code>:</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>numbers&nbsp;</code><code>=</code>&nbsp;<code>[</code><code>1</code><code>,&nbsp;</code><code>2</code><code>,&nbsp;</code><code>3</code><code>,&nbsp;</code><code>4</code><code>,&nbsp;</code><code>5</code><code>]</code></div>\r\n<div><code>parity_dict&nbsp;</code><code>=</code>&nbsp;<code>{n: n</code><code>%</code><code>2</code>&nbsp;<code>=</code><code>=</code>&nbsp;<code>0</code>&nbsp;<code>for</code>&nbsp;<code>n&nbsp;</code><code>in</code>&nbsp;<code>numbers}</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>Таким образом, словарное включение &mdash; это удобный и мощный инструмент для создания словарей в Python, который позволяет сократить код и сделать его более читаемым.</div>",
      "lesson": 18,
      "ordering_number": 15,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 103,
    "fields": {
      "name": "33. Файл .gitignore для чего используется",
      "content": "<div><strong>Файл .gitignore используется в системе контроля версий Git для определения игнорируемых файлов и каталогов.</strong></div>\r\n<div>Этот инструмент позволяет исключить определённые элементы из отслеживания Git, что важно для эффективной работы с проектами, в которых присутствует множество временных, производных или приватных файлов.</div>\r\n<div>В файле .gitignore могут быть указаны шаблоны для игнорирования:</div>\r\n<ul>\r\n<li>временных файлов;</li>\r\n<li>файлов компиляции;</li>\r\n<li>логов и прочих элементов, которые не должны включаться в репозиторий Git.</li>\r\n</ul>",
      "lesson": 15,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 104,
    "fields": {
      "name": "34. Что делает инструкция assert в рамках тестирования кода?",
      "content": "<p><strong>Оператор</strong>&nbsp;assert в Python используется для&nbsp;<strong>отладки и написания тестов</strong>. Это утверждение, которое проверяет, является ли условие истинным. Если условие истинно, выполнение программы продолжается. Если условие ложно, оператор assert вызывает исключение AssertionError, что приводит к остановке выполнения программы.</p>",
      "lesson": 15,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 105,
    "fields": {
      "name": "35. Какие HTTP-методы ты знаешь",
      "content": "<p>GET<br>HEAD<br>POST<br>PUT<br>DELETE<br>PATCH<br><br><br>OPTIONS запрашивает возможности сервера или поддерживаемые им методы<br>TRACE позволяет клиентам получать информацию вносимую или изменяемую промежуточными серверами<br>CONNECT запускает TCP/IP туннель, т.е. двухстороннюю связь с сервером. То</p>",
      "lesson": 15,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 106,
    "fields": {
      "name": "36. Из каких частей состоит веб приложение",
      "content": "<p>Веб-приложение состоит из клиентской и серверной частей, тем самым реализуя технологию &laquo;клиент-сервер&raquo;.<br><br>Клиентская часть реализует пользовательский интерфейс, формирует запросы к серверу и обрабатывает ответы от него.<br><br>Серверная часть получает запрос от клиента, выполняет вычисления, после этого формирует веб-страницу и отправляет её клиенту по сети с использованием протокола HTTP.<br><br>Само веб-приложение может выступать в качестве клиента других служб, например, базы данных или другого веб-приложения, расположенного на другом сервере.</p>",
      "lesson": 15,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 107,
    "fields": {
      "name": "37. Для чего нужны миграции в Django?",
      "content": "<div>Миграции в Django &ndash; это механизм, который позволяет автоматически создавать изменения в базе данных при внесении изменений в модели Django. Они позволяют избежать выполнения SQL-запросов вручную и сохраняют структуру базы данных в коде приложения.</div>\r\n<div>Миграции создаются на основе файлов миграций, которые содержат Python-код, определяющий изменения для базы данных, такие как добавление или удаление таблиц, изменение полей и индексов.</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Миграции базы данных в Django &mdash; это мощный механизм, который позволяет вам управлять изменениями в структуре базы данных вашего приложения. Они обеспечивают удобный способ создания, изменения и удаления таблиц и полей в базе данных, синхронизируя их с моделями Django. Миграции помогают поддерживать базу данных в актуальном состоянии и упрощают процесс развертывания изменений на разных средах. Это особенно важно в условиях командной разработки, где изменения в моделях могут происходить часто и требуют синхронизации между разными разработчиками и средами.</div>\r\n<div>Миграции в Django работают на основе файлов миграций, которые генерируются автоматически при изменении моделей. Эти файлы содержат инструкции для внесения изменений в базу данных, что позволяет легко отслеживать и управлять историей изменений. Миграции также позволяют откатывать изменения, что делает процесс управления базой данных более гибким и безопасным.</div>\r\n</div>",
      "lesson": 15,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 108,
    "fields": {
      "name": "38. Какой UI Kit тебе известен и зачем он используется",
      "content": "<div>User Interface Kit &mdash; UI kit, или UI-кит &mdash; представляет собой &lrm;набор для проектирования пользовательского интерфейса.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;Этот набор состоит из элементов интерфейса: кнопки, поля ввода, переключатели, списки, иконки, таблицы, &mdash; и правил использования шрифтов, цветовой палитры, отступов, сеток и эффектов.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>UI kit &mdash; это библиотека используемых в проекте компонентов, с которой сверяются дизайнеры и разработчик</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>Bootstrap на сегодняшний день является одним из самых популярных CSS-фреймворков &mdash; с его помощью создано около 22% всех сайтов в мире. Чаще всего его используют для создания адаптивных сайтов, а также мобайл-ферст сервисов</div>",
      "lesson": 15,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 109,
    "fields": {
      "name": "39. Как происходит работа с SSH-ключами? Что это такое?",
      "content": "<div><strong>SSH (Secure Shell) &mdash; это протокол, обеспечивающий безопасную работу с удаленным сервером.</strong></div>\r\n<div>С его помощью системный администратор может использовать физически доступный для себя компьютер, чтобы подключиться к серверу, находящемуся в другом городе или на другом конце света, управлять им, обмениваться с ним данными &mdash; совершать любые действия, которые позволит командная строка.</div>\r\n<div>Технологию используют владельцы сайтов для размещения на хостинге веб-ресурса и подготовки системы для его работы, а также для ограничения к нему доступа посторонних лиц.</div>\r\n<p>&nbsp;</p>\r\n<div><strong>Работа с SSH-ключами происходит по принципу &laquo;замок&ndash;ключ&raquo;</strong>. Во время подключения по Secure Socket Shell происходит несколько процессов:</div>\r\n<ol>\r\n<li>Обмен открытыми ключами.</li>\r\n<li>Верификация сообщений.</li>\r\n<li>Аутентификация пользователя на право отправлять команды.</li>\r\n</ol>\r\n<div>Клиент направляет другой стороне свой публичный ключ. Сервер проверяет его по своему списку public-key. Если совпадение есть, генерируется случайное число, для его шифрования применяется открытый ключ сервера. Появляется сообщение с &laquo;заблокированным&raquo; содержимым, которое отправляется пользователю.</div>\r\n<div>На стороне получателя происходит разблокировка &laquo;случайного числа&raquo; с помощью секретного ключа. Результат отправляется на проверку удаленному хосту. Если ключ пользователя смог открыть &laquo;замок&raquo;, аутентификация пройдена и у клиента появляется доступ к серверу.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>SSH-ключи представляют собой пару &mdash; закрытый и открытый ключ. Закрытый должен храниться в закрытом доступе у клиента, открытый отправляется на сервер и размещается в файле ~/.ssh/authorized_keys.</div>\r\n<div>Когда клиент подключается к серверу, сервер отправляет сообщение, зашифрованное с помощью открытого ключа. Если клиент сможет его расшифровать с помощью закрытого ключа и вернуть правильный ответ &mdash; аутентификация пройдена.</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;</div>",
      "lesson": 15,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 110,
    "fields": {
      "name": "40. Назови основные компоненты Docker",
      "content": "<div><strong>Основные компоненты Docker:</strong></div>\r\n<ol>\r\n<li><strong>Docker Engine</strong>&nbsp;&mdash; основной компонент, который обеспечивает создание и работу с контейнерами.</li>\r\n<li><strong>Docker CLI (Command Line Interface)</strong>&nbsp;&mdash; интерфейс командной строки для работы с Docker Engine.</li>\r\n<li><strong>Docker Daemon</strong>&nbsp;&mdash; процесс, который управляет контейнерами и взаимодействует с Docker Engine.</li>\r\n<li><strong>Docker Hub</strong>&nbsp;&mdash; облачный репозиторий для хранения и обмена образами контейнеров.</li>\r\n<li><strong>Docker Compose</strong>&nbsp;&mdash; инструмент для определения и запуска многоконтейнерных приложений.</li>\r\n<li><strong>Docker Swarm</strong> &mdash; оркестратор кластеров Docker, позволяющий работать с множеством узлов.</li>\r\n</ol>",
      "lesson": 15,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 111,
    "fields": {
      "name": "40.1  наиболее часто используемые команды Docker:",
      "content": "<div>наиболее часто используемых команд Docker:</div>\r\n<p><br><br></p>\r\n<div><code>docker run</code>&nbsp;<br>- команда docker run запускает существующий образ и создает из него контейнер</div>\r\n<p><br><br></p>\r\n<div><code>docker build</code>&nbsp;- создает образ из Dockerfile</div>\r\n<p><br><br></p>\r\n<div><code>docker image ls</code>&nbsp;- выводит список всех образов локального репозитория</div>\r\n<p><br><br></p>\r\n<div><code>docker container ls</code>&nbsp;- выводит список всех контейнеров</div>\r\n<p><br><br></p>\r\n<div><code>docker pull</code>&nbsp;- скачивает образ из Docker Hub или другого реестра</div>\r\n<p><br><br></p>\r\n<div><code>docker push</code>&nbsp;- загружает образ в Docker Hub или другой реестр</div>\r\n<p><br><br></p>\r\n<div><code>docker rmi</code> - удаляет образ из локального репозитория</div>",
      "lesson": 15,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 112,
    "fields": {
      "name": "48.4 3NF (третья нормальная форма):",
      "content": "<p><strong>3NF</strong>&nbsp;(третья нормальная форма): все неключевые атрибуты должны быть полностью функциональны в первичном ключе и независимы друг от друга.</p>\r\n<p><br><br>Третья нормальная форма предполагает, что каждый столбец, не являющийся ключом, должен зависеть только от столбца, который является ключом, то есть должна отсутствовать транзитивная функциональная зависимость (transitive functional dependency)</p>",
      "lesson": 18,
      "ordering_number": 16,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 113,
    "fields": {
      "name": "22. Какие элементы могут быть ключом от словаря?",
      "content": "<div><strong>Ключом</strong>&nbsp;<strong>может</strong>&nbsp;<strong>быть</strong>&nbsp;произвольный неизменяемый тип данных: различные числа, строки, кортежи.&nbsp;<strong>Ключом</strong>&nbsp;в&nbsp;<strong>словаре</strong>&nbsp;не&nbsp;<strong>может</strong>&nbsp;<strong>быть</strong>&nbsp;множество, но&nbsp;<strong>может</strong>&nbsp;<strong>быть</strong>&nbsp;неизменяемый&nbsp;<strong>элемент</strong>&nbsp;типа frozenset. Значением&nbsp;<strong>элемента</strong>&nbsp;<strong>словаря</strong>&nbsp;<strong>может</strong>&nbsp;<strong>быть</strong>&nbsp;любой изменяемый или неизменяемый тип данных. Пустой&nbsp;<strong>словарь</strong>&nbsp;в&nbsp;<strong>Python</strong>, как и в JavaScript, можно создать двумя способами: через функцию dict () или с помощью фигурных скобок.</div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>",
      "lesson": 14,
      "ordering_number": 2,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 114,
    "fields": {
      "name": "23. Назови магические методы, которые ты знаешь.",
      "content": "<div>Магические методы - это методы Python, которые определяют, как ведут себя объекты Python при выполнении над ними обычных операций.&nbsp;</div>\r\n<div>Эти методы четко определены с помощью двойного подчеркивания до и после имени метода.</div>\r\n<div>В результате их обычно называют методами дандера, как в&nbsp;<strong>d</strong>ouble&nbsp;<strong>под</strong>оценкой.&nbsp;</div>\r\n<div>Распространенный метод dunder, с которым вы, возможно, уже сталкивались, - это __init__() метод, который используется для определения конструкторов классов.</div>\r\n<div>Как правило, методы dunder не предназначены для вызова непосредственно в вашем коде; скорее, они будут вызываться интерпретатором во время выполнения программы.</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<h2>Как определить магические методы</h2>\r\n<div>Как упоминалось ранее, магические методы определяют поведение объектов. Как таковые, они определены как часть класса объекта. Поскольку они являются частью класса object, они принимают в качестве первого аргумента self, который является ссылкой на сам объект.</div>\r\n<div>Они могут принимать дополнительные аргументы в зависимости от того, как они будут вызваны интерпретатором. Они также четко определены двумя символами подчеркивания перед и после их названий.</div>\r\n</div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>Магические методы являются полезной концепцией в объектно-ориентированном программировании на Python. Используя их, вы указываете поведение ваших пользовательских типов данных, когда они используются с обычными встроенными операциями. Эти операции включают:</div>\r\n<div>🟢 Арифметические операции</div>\r\n<div>🟢 Операции сравнения</div>\r\n<div>🟢 Операции жизненного цикла</div>\r\n<div>🟢 Операции представления</div>\r\n</div>\r\n<div>\r\n<h3>#1. Арифметические операции</h3>\r\n</div>\r\n<div><img src=\"http://127.0.0.1:55104/scale_2400.png\"></div>\r\n<div>\r\n<h3>#2. Операции сравнения</h3>\r\n</div>\r\n<div><img src=\"http://127.0.0.1:55104/scale_2400-5e9d388483d73f3b07bf9593afba924fd8005ec4.png\"></div>\r\n<div>&nbsp;</div>\r\n<div>\r\n<h3>#3. Операции жизненного цикла</h3>\r\n</div>\r\n<div><img src=\"http://127.0.0.1:55104/scale_2400-8b580647a3ca973d3a4034c7a02788d9e8663704.png\"></div>\r\n<div>\r\n<h3>#4. Операции представления</h3>\r\n<div>&nbsp;</div>\r\n<div><img src=\"http://127.0.0.1:55104/scale_2400-0e28926d903aa7f1a7dca7c68ca7464cc28fd702.png\"></div>\r\n</div>",
      "lesson": 14,
      "ordering_number": 3,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 115,
    "fields": {
      "name": "24. Чем абстрактный класс отличается от обычного?",
      "content": "<h2>Абстрактный класс</h2>\r\n<div>Абстрактный класс &mdash; это класс, который не может быть инстанциирован, то есть нельзя создать его экземпляр. Он представляет собой шаблон или чертеж для создания других классов. Абстрактный класс может содержать абстрактные методы (методы без реализации) и/или обычные методы.</div>\r\n<div>Простой пример абстрактного класса:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>from</code>&nbsp;<code>abc&nbsp;</code><code>import</code>&nbsp;<code>ABC, abstractmethod</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>class</code>&nbsp;<code>AbstractClassExample(ABC):</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@abstractmethod</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>do_something(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pass</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере&nbsp;<code>AbstractClassExample</code>&nbsp;&mdash; это абстрактный класс, который содержит абстрактный метод&nbsp;<code>do_something</code>. Этот метод должен быть обязательно реализован в любом классе, который наследует&nbsp;<code>AbstractClassExample</code>.</div>\r\n<h2>Интерфейс</h2>\r\n<div>В Python нет встроенной поддержки интерфейсов, как это есть, например, в Java. Однако концепцию интерфейса можно реализовать с помощью абстрактного класса, в котором все методы являются абстрактными.</div>\r\n<div>Пример интерфейса:</div>\r\n<div>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<div>1</div>\r\n<div>2</div>\r\n<div>3</div>\r\n<div>4</div>\r\n<div>5</div>\r\n<div>6</div>\r\n<div>7</div>\r\n<div>8</div>\r\n<div>9</div>\r\n<div>10</div>\r\n<div>11</div>\r\n</td>\r\n<td>\r\n<div>\r\n<div><code>from</code>&nbsp;<code>abc&nbsp;</code><code>import</code>&nbsp;<code>ABC, abstractmethod</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>class</code>&nbsp;<code>InterfaceExample(ABC):</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@abstractmethod</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>method1(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pass</code></div>\r\n<div>&nbsp;</div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>@abstractmethod</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>def</code>&nbsp;<code>method2(</code><code>self</code><code>):</code></div>\r\n<div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pass</code></div>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</div>\r\n<div>В этом примере&nbsp;<code>InterfaceExample</code>&nbsp;&mdash; это интерфейс, который содержит два абстрактных метода:&nbsp;<code>method1</code>&nbsp;и&nbsp;<code>method2</code>. Любой класс, который наследует&nbsp;<code>InterfaceExample</code>, должен реализовать оба этих метода.</div>\r\n<blockquote>\r\n<div>Изучайте Python на&nbsp;<a href=\"https://sky.pro/courses/programming/python-web-course?utm_source=skypro_blog&amp;utm_medium=free&amp;utm_campaign=raznicza-mezhdu-abstraktnym-klassom-i-interfejsom-v-python\">онлайн-курсе от Skypro &laquo;Python-разработчик&raquo;</a>. Программа рассчитана на новичков без опыта программирования и технического образования. Курс проходит в формате записанных коротких видеолекций. Будет много проверочных заданий и мастер-классов. В конце каждой недели &mdash; живая встреча с экспертами в разработке для ответов на вопросы и разбора домашек.</div>\r\n</blockquote>\r\n<h2>В чем разница?</h2>\r\n<div>В Python разница между абстрактным классом и интерфейсом довольно размыта, так как оба они реализуются с использованием механизма абстрактных классов. Однако важно понимать, что принципиальное отличие между ними заключается в том, что абстрактный класс может иметь как абстрактные, так и неабстрактные методы, тогда как интерфейс содержит только абстрактные методы.</div>\r\n<div>Следовательно, абстрактный класс можно использовать для создания общей функциональности для группы связанных классов, а интерфейс &mdash; для определения общего поведения группы классов, возможно, не связанных между собой.</div>",
      "lesson": 14,
      "ordering_number": 4,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 116,
    "fields": {
      "name": "25. Можно ли положить список внутрь кортежа и почему?",
      "content": "<div><strong>Да, список можно положить внутрь кортежа в Python</strong>.&nbsp;</div>\r\n<div>Кортеж &mdash; это неизменяемая структура данных, но&nbsp;<strong>внутри него могут находиться изменяемые элементы, например списки</strong>. В таком случае значения этих элементов можно изменить.&nbsp;</div>\r\n<div>Контейнеры в Python хранят только ссылки на объекты, но не сами объекты. Поэтому кортеж не может контролировать изменение объектов, ссылки на которые он хранит. Он может гарантировать только то, что набор ссылок внутри него не будет изменён.&nbsp;</div>",
      "lesson": 14,
      "ordering_number": 5,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 117,
    "fields": {
      "name": "26. Сериализатор – что это такое?",
      "content": "<div>\r\n<div>\r\n<p>Сериализаторы позволяют преобразовывать сложные данные, такие как</p>\r\n<ul>\r\n<li>наборы запросов</li>\r\n<li>и экземпляры моделей,</li>\r\n</ul>\r\n<br>в собственные типы данных Python,</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;которые затем могут быть легко преобразованы в <code>JSON</code>,&nbsp;<code>XML</code>&nbsp;или другие типы содержимого.</div>\r\n<div>&nbsp;</div>\r\n<div>&nbsp;Сериализаторы также обеспечивают десериализацию, позволяя преобразовывать разобранные данные обратно в сложные типы после предварительной проверки входящих данных.</div>\r\n<br><br>\r\n<div>Сериализаторы в DRF работают очень похоже на классы Django&nbsp;<code>Form</code>&nbsp;и&nbsp;<code>ModelForm</code>. Мы предоставляем класс&nbsp;<code>Serializer</code>, который дает вам мощный, универсальный способ управления выводом ваших ответов, а также класс&nbsp;<code>ModelSerializer</code>, который предоставляет полезный ярлык для создания сериализаторов, работающих с экземплярами моделей и наборами запросов.</div>\r\n</div>\r\n<div>&nbsp;</div>",
      "lesson": 14,
      "ordering_number": 6,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 118,
    "fields": {
      "name": "27. Какие запросы к базам данных ты знаешь?",
      "content": "<ol>\r\n<li>\r\n<div>Ключевые слова этого языка делят на четыре логические группы.</div>\r\n<div>1️⃣&nbsp;<strong>DDL</strong></div>\r\n<div>Data Definition Language &mdash; язык определения данных. В него входят ключевые слова CREATE, DROP, RENAME и другие, которые относят к определению и&nbsp;манипулированию структурой базы данных.</div>\r\n<div>2️⃣&nbsp;<strong>DML</strong></div>\r\n<div>Data Manipulation Language &mdash; язык манипулирования данными. В этой группе &mdash; запросы SELECT, INSERT, UPDATE, DELETE и другие. Их используют, чтобы изменять, получать, обновлять и удалять данные из базы.</div>\r\n<div>3️⃣&nbsp;<strong>DCL</strong></div>\r\n<div>Data Control Language&nbsp; &mdash; язык управления данными. К этой группе относят запросы разрешений, прав и различных ограничивающих доступ настроек. Например, GRANT или DENY.</div>\r\n<div>4️⃣&nbsp;<strong>TCL</strong></div>\r\n<div>Transaction Control Language &mdash; язык управления транзакциями. В эту группу входят все запросы, которые относят к управлению транзакциями и их жизненными циклами. Например, BEGIN TRANSACTION, ROLLBACK TRANSACTION, COMMIT TRANSACTION.</div>\r\n</li>\r\n</ol>\r\n<div>&nbsp;</div>\r\n<div>\r\n<div>последовательность выполнения операций на сервере (<strong>не равно</strong>&nbsp;порядку записи ключевых слов в запросе):</div>\r\n<div>&nbsp;</div>\r\n<div>PostgreSQL:&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li>FROM =&gt;</li>\r\n<li>=&gt; WHERE =&gt;</li>\r\n<li>=&gt; GROUP BY =&gt;</li>\r\n<li>=&gt; HAVING =&gt;</li>\r\n<li>=&gt; SELECT =&gt;</li>\r\n<li>=&gt; DISTINCT =&gt;</li>\r\n<li>=&gt; ORDER BY =&gt;</li>\r\n<li>=&gt; LIMIT.</li>\r\n</ul>\r\n</div>\r\n<div>MySQL:&nbsp;</div>\r\n<div>\r\n<ul>\r\n<li>FROM&nbsp;</li>\r\n<li>=&gt; WHERE&nbsp;</li>\r\n<li>=&gt; SELECT&nbsp;</li>\r\n<li>=&gt; GROUP BY</li>\r\n<li>&nbsp;=&gt; HAVING&nbsp;</li>\r\n<li>=&gt; ORDER BY&nbsp;</li>\r\n<li>=&gt; LIMIT.</li>\r\n</ul>\r\n</div>\r\n</div>",
      "lesson": 14,
      "ordering_number": 7,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 119,
    "fields": {
      "name": "27.1 DDL (Data Definition Language) в PostgreSQL",
      "content": "<div><strong>DDL (Data Definition Language) в PostgreSQL</strong>&nbsp;&mdash; это группа команд, которые используются для создания и изменения структуры объектов базы данных: таблиц, представлений, схем и индексов.&nbsp;</div>\r\n<div><strong>Основные варианты DDL-операторов</strong>:&nbsp;</div>\r\n<ul>\r\n<li><strong>CREATE</strong>.&nbsp;&nbsp;Создаёт новые объекты в базе данных, такие как таблицы, индексы, представления, функции, триггеры и другие.&nbsp;</li>\r\n<li><strong>ALTER</strong>.&nbsp;&nbsp;Используется для изменения структуры или свойств существующих объектов в базе данных. Например, добавление или удаление столбцов, изменение типов данных и другие операции.&nbsp;</li>\r\n<li><strong>DROP</strong>.&nbsp;&nbsp;Используется для удаления объектов из базы данных. Например, удаление таблицы и связанных с ней данных и индексов, удаление индекса, представления или функции.&nbsp;</li>\r\n<li><strong>TRUNCATE</strong>. Используется для удаления всех записей из таблицы, сохраняя структуру таблицы. Это более эффективный способ удаления данных, чем использование&nbsp;\r\n<pre>DELETE FROM TABLE</pre>\r\n, так как TRUNCATE не сохраняет журнал транзакций.&nbsp;</li>\r\n</ul>\r\n<p><br><br><br>1. CREATE TABLE (Создать Таблицу)<br>Назначение : Создает новую таблицу в базе данных.<br>Синтаксис :<br>sql<br>CREATE TABLE имя_таблицы (<br>колонка1 тип_данных,<br>колонка2 тип_данных,<br>колонка3 тип_данных,<br>...<br>);<br>Пример :<br>sql<br>CREATE TABLE Сотрудники (<br>ИдентификаторСотрудника int,<br>Имя varchar(255),<br>Фамилия varchar(255),<br>ДатаРождения date<br>);<br>2. ALTER TABLE (Изменить Таблицу)<br>Назначение : Модифицирует существующую таблицу (например, добавляет колонку).<br>Синтаксис :<br>sql<br>ALTER TABLE имя_таблицы ADD имя_колонки тип_данных;<br>Пример :<br>sql<br>ALTER TABLE Сотрудники ADD ЭлектроннаяПочта varchar(255);<br>3. DROP TABLE (Удалить Таблицу)<br>Назначение : Удаляет существующую таблицу из базы данных.<br>Синтаксис :<br>sql<br>DROP TABLE имя_таблицы;<br>Пример :<br>sql<br>DROP TABLE Сотрудники;<br>4. TRUNCATE TABLE (Очистить Таблицу)<br>Назначение : Удаляет все данные из таблицы, но не саму таблицу.<br>Синтаксис :<br>sql<br>TRUNCATE TABLE имя_таблицы;<br>Пример :<br>sql<br>TRUNCATE TABLE Сотрудники;<br>5. CREATE INDEX (Создать Индекс)<br>Назначение : Создает индекс на колонке таблицы для более быстрого доступа к данным.<br>Синтаксис :<br>sql<br>CREATE INDEX имя_индекса ON имя_таблицы (колонка1, колонка2, ...);<br>Пример :<br>sql<br>CREATE INDEX idx_фамилия ON Сотрудники (Фамилия);<br>6. DROP INDEX (Удалить Индекс)<br>Назначение : Удаляет индекс из таблицы.<br>Синтаксис :<br>sql<br>DROP INDEX имя_индекса ON имя_таблицы;<br>Примечание: Синтаксис может немного отличаться в зависимости от системы базы данных.<br>Пример :<br>sql<br>DROP INDEX idx_фамилия ON Сотрудники;<br>7. RENAME TABLE (Переименовать Таблицу)<br>Назначение : Переименовывает существующую таблицу.<br>Синтаксис :<br>sql<br>ALTER TABLE имя_таблицы RENAME TO новое_имя_таблицы;<br>Пример :<br>sql<br>ALTER TABLE Сотрудники RENAME TO Персонал;<br>Помните, что точный синтаксис этих команд может немного отличаться в зависимости от системы баз данных SQL (например, MySQL, PostgreSQL, SQL Server и т.д.). Всегда обращайтесь к конкретной документации вашей системы баз данных для получения наиболее точной информации.</p>",
      "lesson": 14,
      "ordering_number": 8,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 120,
    "fields": {
      "name": "27.2 DML (Data Manipulation Language)",
      "content": "<div><strong>DML (Data Manipulation Language)</strong>&nbsp;&mdash; это группа операторов в языке SQL, которые позволяют получать и изменять записи, присутствующие в таблице.</div>\r\n<div>Вот некоторые DML-команды:</div>\r\n<ol>\r\n<li><strong>SELECT</strong>&nbsp;&mdash; используется для получения кортежей из таблицы.</li>\r\n<li><strong>INSERT INTO</strong>&nbsp;&mdash; применяется для добавления новых записей в таблицу.</li>\r\n<li><strong>DELETE</strong>&nbsp;&mdash; позволяет удалить одну или несколько записей.</li>\r\n<li><strong>UPDATE</strong> &mdash; используется для обновления и изменения значений записи в таблице.</li>\r\n</ol>",
      "lesson": 14,
      "ordering_number": 9,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 121,
    "fields": {
      "name": "28. Что такое __pychache__?",
      "content": "<div>\r\n<div>\r\n<div>При работе с Python часто можно заметить, что в папке проекта автоматически создается папка __pycache__. Это может вызвать вопросы, особенно у тех, кто только</div>\r\n</div>\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>\r\n<div>\r\n<div>При работе с Python часто можно заметить, что в папке проекта автоматически создается папка&nbsp;<code>__pycache__</code>. Это может вызвать вопросы, особенно у тех, кто только начинает изучать язык.</div>\r\n<h2>Что такое&nbsp;<code>__pycache__</code>?</h2>\r\n<div>Папка&nbsp;<code>__pycache__</code>&nbsp;&mdash; это каталог, который создается Python&rsquo;ом, когда программа запускается. В этой папке хранятся скомпилированные байт-коды файлов.</div>\r\n<h2>Зачем нужен&nbsp;<code>__pycache__</code>?</h2>\r\n<div>Компиляция исходного кода в байт-код позволяет ускорить загрузку модулей при следующем запуске программы. То есть, Python использует&nbsp;<code>__pycache__</code>&nbsp;для оптимизации работы с кодом.</div>\r\n<h2>Можем ли мы удалять&nbsp;<code>__pycache__</code>?</h2>\r\n<div>Да, можно безопасно удалять содержимое папки&nbsp;<code>__pycache__</code>&nbsp;или даже саму папку. Python снова создаст все необходимые файлы при следующем запуске программы. Однако, удалять эту папку обычно нет необходимости, так как она не влияет на работу исходного кода.</div>\r\n<h2>Должны ли мы распространять&nbsp;<code>__pycache__</code>?</h2>\r\n<div>Нет, папку&nbsp;<code>__pycache__</code>&nbsp;не следует включать в распространяемый пакет исходного кода или в репозиторий. Это приведет только к увеличению размера пакета и может вызвать проблемы совместимости, так как байт-код может быть специфичным для конкретной версии Python и платформы. Часто в файле&nbsp;<code>.gitignore</code>&nbsp;добавляют&nbsp;<code>__pycache__</code>, чтобы исключить его из репозитория.</div>\r\n<div>В заключение, папка&nbsp;<code>__pycache__</code> является важным инструментом для оптимизации работы Python, но не играет никакой роли в распространении исходного кода.</div>\r\n</div>",
      "lesson": 14,
      "ordering_number": 10,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 122,
    "fields": {
      "name": "29. В чем разница между БД и СУБД?",
      "content": "<p><strong>Базы</strong>&nbsp;<strong>данных</strong>&nbsp;- это специально разработанное хранилище для различных типов данных. Каждая&nbsp;<strong>база</strong>&nbsp;<strong>данных</strong>, имеет определённую модель (реляционная, документно-ориентированная), которая обеспечивает удобный доступ к данным.<br>База данных (БД)&nbsp;&mdash; это совокупность данных, организованных в соответствии с определенными правилами<br>и предназначенных для хранения и манипуляций с ними.<br><br>БД используются для хранения информации о компании, клиентах, продуктах и многом другом.<br><br>&nbsp;<strong>Системы</strong>&nbsp;<strong>управления</strong>&nbsp;<strong>базами</strong>&nbsp;<strong>данных</strong>&nbsp;(<strong>СУБД</strong>) - специальные приложения (или библиотеки) для&nbsp;<strong>управления</strong>&nbsp;<strong>базами</strong>&nbsp;<strong>данных</strong> различных размеров и форм.</p>",
      "lesson": 14,
      "ordering_number": 11,
      "steps_used_users": []
    }
  },
  {
    "model": "content_app.step",
    "pk": 123,
    "fields": {
      "name": "30. Какие виды систем управления баз данных тебе известны? Назови примеры СУБД, относящиеся к разным типам",
      "content": "<div>Существует несколько видов систем управления базами данных (СУБД). Вот некоторые из них:</div>\r\n<ol>\r\n<li><strong>По модели данных:</strong></li>\r\n</ol>\r\n<div>&mdash; иерархические,<br>&mdash; сетевые,<br>&mdash; реляционные,<br>&mdash; объектно-ориентированные,<br>&mdash; объектно-реляционные.Примеры: PostgreSQL, DB2, Oracle, Microsoft SQL Server.</div>\r\n<ol>\r\n<li><strong>По степени распределённости:</strong></li>\r\n</ol>\r\n<div>&mdash; локальные,<br>&mdash; распределённые.</div>\r\n<ol>\r\n<li><strong>По способу доступа к БД:</strong></li>\r\n</ol>\r\n<div>&mdash; файл-серверные,Примеры: Microsoft Access, Paradox, dBase, FoxPro, Visual FoxPro.<br>&mdash; клиент-серверные,Примеры: Oracle, Firebird, Interbase, IBM DB2, Informix, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Cach&eacute;, ЛИНТЕР.<br>&mdash; встраиваемые.Примеры: OpenEdge, SQLite, BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact, ЛИНТЕР.</div>",
      "lesson": 14,
      "ordering_number": 12,
      "steps_used_users": []
    }
  },
  {
    "model": "users.user",
    "pk": 1,
    "fields": {
      "password": "pbkdf2_sha256$600000$qetPRqmROyOUWhINYKxdk3$GXi5FWRE6e5CI+pJu5UogifbGNv9bD1pthLQXYYXhng=",
      "last_login": "2024-09-17T19:21:13.525Z",
      "is_superuser": true,
      "first_name": "django0292",
      "last_name": "",
      "is_staff": true,
      "is_active": true,
      "date_joined": "2024-09-06T09:54:07.089Z",
      "email": "django0292@gmail.com",
      "phone": null,
      "avatar": "",
      "token": null,
      "groups": [],
      "user_permissions": []
    }
  },
  {
    "model": "users.user",
    "pk": 2,
    "fields": {
      "password": "pbkdf2_sha256$600000$Y4HNwRsdj735X6y7Z5i4en$/fsmwpEUtuwdJsx+j4rYm6o+0pw8y9wwQoWGS4ennR4=",
      "last_login": "2024-09-16T17:30:09.417Z",
      "is_superuser": false,
      "first_name": "",
      "last_name": "",
      "is_staff": false,
      "is_active": true,
      "date_joined": "2024-09-16T13:04:08.690Z",
      "email": "AlSrVch@yandex.ru",
      "phone": null,
      "avatar": "",
      "token": "5d31bb88a8a5de1dec7b3ce927f7a2fe",
      "groups": [],
      "user_permissions": []
    }
  },
  {
    "model": "users.payment",
    "pk": 17,
    "fields": {
      "user": 1,
      "payment_date": null,
      "course": 3,
      "payment_link": "https://checkout.stripe.com/c/pay/cs_test_a1IMuswPelYSrSBlDwAJgAk6WhTNzSFuKmc93jrRngGM86NCjwB6TXZTEH#fidkdWxOYHwnPyd1blpxYHZxWjA0VW1Rc05ARFBNMzdVUkRpVmx8NXAxTTFfS1NDNXVUbjZuVkNRdlxhSGx2S3RmQTBkVT1RR29hfDdtdFJjQT1KSDZRMjB8Q003TVRAb2hqVXxVSEZHXE98NTV1cE1fPWMzbScpJ2N3amhWYHdzYHcnP3F3cGApJ2lkfGpwcVF8dWAnPyd2bGtiaWBabHFgaCcpJ2BrZGdpYFVpZGZgbWppYWB3dic%2FcXdwYHgl",
      "payment_id": "cs_test_a1IMuswPelYSrSBlDwAJgAk6WhTNzSFuKmc93jrRngGM86NCjwB6TXZTEH",
      "summ": "1030.00"
    }
  },
  {
    "model": "users.payment",
    "pk": 19,
    "fields": {
      "user": 2,
      "payment_date": null,
      "course": 3,
      "payment_link": "https://checkout.stripe.com/c/pay/cs_test_a1loQJPLyrYhL5oH6B9XvLoESGC3KATc0QJG98xXx1u43beXW09AvyLXh0#fidkdWxOYHwnPyd1blpxYHZxWjA0VW1Rc05ARFBNMzdVUkRpVmx8NXAxTTFfS1NDNXVUbjZuVkNRdlxhSGx2S3RmQTBkVT1RR29hfDdtdFJjQT1KSDZRMjB8Q003TVRAb2hqVXxVSEZHXE98NTV1cE1fPWMzbScpJ2N3amhWYHdzYHcnP3F3cGApJ2lkfGpwcVF8dWAnPyd2bGtiaWBabHFgaCcpJ2BrZGdpYFVpZGZgbWppYWB3dic%2FcXdwYHgl",
      "payment_id": "cs_test_a1loQJPLyrYhL5oH6B9XvLoESGC3KATc0QJG98xXx1u43beXW09AvyLXh0",
      "summ": "1030.00"
    }
  }
]